var escrow_core=function(t){"use strict";function e(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function n(t,...e){if(!((n=t)instanceof Uint8Array||ArrayBuffer.isView(n)&&"Uint8Array"===n.constructor.name))throw new Error("Uint8Array expected");var n;if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function r(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}const o="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function i(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function s(t,e){return t<<32-e|t>>>e}function f(t){return"string"==typeof t&&(t=function(t){if("string"!=typeof t)throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),n(t),t}class c{clone(){return this._cloneInto()}}function u(t){const e=e=>t().update(f(e)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function a(t=32){if(o&&"function"==typeof o.getRandomValues)return o.getRandomValues(new Uint8Array(t));if(o&&"function"==typeof o.randomBytes)return o.randomBytes(t);throw new Error("crypto.getRandomValues must be defined")}function h(t,e,n){return t&e^t&n^e&n}class d extends c{constructor(t,e,n,r){super(),this.blockLen=t,this.outputLen=e,this.padOffset=n,this.isLE=r,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=i(this.buffer)}update(t){r(this);const{view:e,buffer:n,blockLen:o}=this,s=(t=f(t)).length;for(let r=0;r<s;){const f=Math.min(o-this.pos,s-r);if(f!==o)n.set(t.subarray(r,r+f),this.pos),this.pos+=f,r+=f,this.pos===o&&(this.process(e,0),this.pos=0);else{const e=i(t);for(;o<=s-r;r+=o)this.process(e,r)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){r(this),function(t,e){n(t);const r=e.outputLen;if(t.length<r)throw new Error("digestInto() expects output buffer of length at least "+r)}(t,this),this.finished=!0;const{buffer:e,view:o,blockLen:s,isLE:f}=this;let{pos:c}=this;e[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>s-c&&(this.process(o,0),c=0);for(let t=c;t<s;t++)e[t]=0;!function(t,e,n,r){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,n,r);const o=BigInt(32),i=BigInt(4294967295),s=Number(n>>o&i),f=Number(n&i),c=r?4:0,u=r?0:4;t.setUint32(e+c,s,r),t.setUint32(e+u,f,r)}(o,s-8,BigInt(8*this.length),f),this.process(o,0);const u=i(t),a=this.outputLen;if(a%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=a/4,d=this.get();if(h>d.length)throw new Error("_sha2: outputLen bigger than state");for(let t=0;t<h;t++)u.setUint32(4*t,d[t],f)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const n=t.slice(0,e);return this.destroy(),n}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:n,length:r,finished:o,destroyed:i,pos:s}=this;return t.length=r,t.pos=s,t.finished=o,t.destroyed=i,r%e&&t.buffer.set(n),t}}const l=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),g=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),w=new Uint32Array(64);class p extends d{constructor(){super(64,32,8,!1),this.A=0|g[0],this.B=0|g[1],this.C=0|g[2],this.D=0|g[3],this.E=0|g[4],this.F=0|g[5],this.G=0|g[6],this.H=0|g[7]}get(){const{A:t,B:e,C:n,D:r,E:o,F:i,G:s,H:f}=this;return[t,e,n,r,o,i,s,f]}set(t,e,n,r,o,i,s,f){this.A=0|t,this.B=0|e,this.C=0|n,this.D=0|r,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|f}process(t,e){for(let n=0;n<16;n++,e+=4)w[n]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=w[t-15],n=w[t-2],r=s(e,7)^s(e,18)^e>>>3,o=s(n,17)^s(n,19)^n>>>10;w[t]=o+w[t-7]+r+w[t-16]|0}let{A:n,B:r,C:o,D:i,E:f,F:c,G:u,H:a}=this;for(let t=0;t<64;t++){const e=a+(s(f,6)^s(f,11)^s(f,25))+((d=f)&c^~d&u)+l[t]+w[t]|0,g=(s(n,2)^s(n,13)^s(n,22))+h(n,r,o)|0;a=u,u=c,c=f,f=i+e|0,i=o,o=r,r=n,n=e+g|0}var d;n=n+this.A|0,r=r+this.B|0,o=o+this.C|0,i=i+this.D|0,f=f+this.E|0,c=c+this.F|0,u=u+this.G|0,a=a+this.H|0,this.set(n,r,o,i,f,c,u,a)}roundClean(){w.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const y=u((()=>new p));function b(t){if(t>Number.MAX_SAFE_INTEGER)throw new TypeError("Number exceeds safe bounds!")}function m(t,e){if(t!==e)throw new TypeError(`Bech32 prefix does not match: ${t} !== ${e}`)}const E=new TextEncoder,x=new TextDecoder;function v(t){return E.encode(t)}function _(t){return x.decode(t)}function B(t,e){!function(t){if(null!==t.match(/[^a-fA-f0-9]/))throw new TypeError("Invalid characters in hex string: "+t);if(t.length%2!=0)throw new Error(`Length of hex string is invalid: ${t.length}`)}(t);const n=t.length/2;if(void 0===e&&(e=n),n>e)throw new TypeError(`Hex string is larger than array size: ${n} > ${e}`);return e}
/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function A(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function I(t,e){return!!Array.isArray(e)&&(0===e.length||(t?e.every((t=>"string"==typeof t)):e.every((t=>Number.isSafeInteger(t)))))}function S(t){if("function"!=typeof t)throw new Error("function expected");return!0}function k(t,e){if("string"!=typeof e)throw new Error(`${t}: string expected`);return!0}function U(t){if(!Number.isSafeInteger(t))throw new Error(`invalid integer: ${t}`)}function O(t){if(!Array.isArray(t))throw new Error("array expected")}function N(t,e){if(!I(!0,e))throw new Error(`${t}: array of strings expected`)}function R(t,e){if(!I(!1,e))throw new Error(`${t}: array of numbers expected`)}function T(...t){const e=t=>t,n=(t,e)=>n=>t(e(n));return{encode:t.map((t=>t.encode)).reduceRight(n,e),decode:t.map((t=>t.decode)).reduce(n,e)}}function L(t){const e="string"==typeof t?t.split(""):t,n=e.length;N("alphabet",e);const r=new Map(e.map(((t,e)=>[t,e])));return{encode:r=>(O(r),r.map((r=>{if(!Number.isSafeInteger(r)||r<0||r>=n)throw new Error(`alphabet.encode: digit index outside alphabet "${r}". Allowed: ${t}`);return e[r]}))),decode:e=>(O(e),e.map((e=>{k("alphabet.decode",e);const n=r.get(e);if(void 0===n)throw new Error(`Unknown letter: "${e}". Allowed: ${t}`);return n})))}}function z(t=""){return k("join",t),{encode:e=>(N("join.decode",e),e.join(t)),decode:e=>(k("join.decode",e),e.split(t))}}function q(t,e,n){if(e<2)throw new Error(`convertRadix: invalid from=${e}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);if(O(t),!t.length)return[];let r=0;const o=[],i=Array.from(t,(t=>{if(U(t),t<0||t>=e)throw new Error(`invalid integer: ${t}`);return t})),s=i.length;for(;;){let t=0,f=!0;for(let o=r;o<s;o++){const s=i[o],c=e*t,u=c+s;if(!Number.isSafeInteger(u)||c/e!==t||u-s!==c)throw new Error("convertRadix: carry overflow");const a=u/n;t=u%n;const h=Math.floor(a);if(i[o]=h,!Number.isSafeInteger(h)||h*n+t!==u)throw new Error("convertRadix: carry overflow");f&&(h?f=!1:r=o)}if(o.push(t),f)break}for(let e=0;e<t.length-1&&0===t[e];e++)o.push(0);return o.reverse()}const H=(t,e)=>0===e?t:H(e,t%e),$=(t,e)=>t+(e-H(t,e)),P=(()=>{let t=[];for(let e=0;e<40;e++)t.push(2**e);return t})();function j(t,e,n,r){if(O(t),e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if($(e,n)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${n} carryBits=${$(e,n)}`);let o=0,i=0;const s=P[e],f=P[n]-1,c=[];for(const r of t){if(U(r),r>=s)throw new Error(`convertRadix2: invalid data word=${r} from=${e}`);if(o=o<<e|r,i+e>32)throw new Error(`convertRadix2: carry overflow pos=${i} from=${e}`);for(i+=e;i>=n;i-=n)c.push((o>>i-n&f)>>>0);const t=P[i];if(void 0===t)throw new Error("invalid carry");o&=t-1}if(o=o<<n-i&f,!r&&i>=e)throw new Error("Excess padding");if(!r&&o>0)throw new Error(`Non-zero padding: ${o}`);return r&&i>0&&c.push(o>>>0),c}function C(t,e=!1){if(U(t),t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if($(8,t)>32||$(t,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!A(n))throw new Error("radix2.encode input should be Uint8Array");return j(Array.from(n),8,t,!e)},decode:n=>(R("radix2.decode",n),Uint8Array.from(j(n,t,8,e)))}}function V(t){return S(t),function(...e){try{return t.apply(null,e)}catch(t){}}}const F=T(C(6),L("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),function(t,e="="){return U(t),k("padding",e),{encode(n){for(N("padding.encode",n);n.length*t%8;)n.push(e);return n},decode(n){N("padding.decode",n);let r=n.length;if(r*t%8)throw new Error("padding: invalid, string should have whole number of bytes");for(;r>0&&n[r-1]===e;r--){if((r-1)*t%8==0)throw new Error("padding: invalid, string has too much padding")}return n.slice(0,r)}}}(6),z("")),D=T(C(6),L("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),z("")),Z=(M="123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz",T(function(t){return U(t),{encode:e=>{if(!A(e))throw new Error("radix.encode input should be Uint8Array");return q(Array.from(e),256,t)},decode:e=>(R("radix.decode",e),Uint8Array.from(q(e,t,256)))}}(58),L(M),z("")));var M;const K=t=>{return T((n=e=>t(t(e)),U(e=4),S(n),{encode(t){if(!A(t))throw new Error("checksum.encode: input should be Uint8Array");const r=n(t).slice(0,e),o=new Uint8Array(t.length+e);return o.set(t),o.set(r,t.length),o},decode(t){if(!A(t))throw new Error("checksum.decode: input should be Uint8Array");const r=t.slice(0,-e),o=t.slice(-e),i=n(r).slice(0,e);for(let t=0;t<e;t++)if(i[t]!==o[t])throw new Error("Invalid checksum");return r}}),Z);var e,n},W=T(L("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),z("")),Y=[996825010,642813549,513874426,1027748829,705979059];function G(t){const e=t>>25;let n=(33554431&t)<<5;for(let t=0;t<Y.length;t++)1==(e>>t&1)&&(n^=Y[t]);return n}function J(t,e,n=1){const r=t.length;let o=1;for(let e=0;e<r;e++){const n=t.charCodeAt(e);if(n<33||n>126)throw new Error(`Invalid prefix (${t})`);o=G(o)^n>>5}o=G(o);for(let e=0;e<r;e++)o=G(o)^31&t.charCodeAt(e);for(let t of e)o=G(o)^t;for(let t=0;t<6;t++)o=G(o);return o^=n,W.encode(j([o%P[30]],30,5,!1))}function X(t){const e="bech32"===t?1:734539939,n=C(5),r=n.decode,o=n.encode,i=V(r);function s(t,n,r=90){k("bech32.encode prefix",t),A(n)&&(n=Array.from(n)),R("bech32.encode",n);const o=t.length;if(0===o)throw new TypeError(`Invalid prefix length ${o}`);const i=o+7+n.length;if(!1!==r&&i>r)throw new TypeError(`Length ${i} exceeds limit ${r}`);const s=t.toLowerCase(),f=J(s,n,e);return`${s}1${W.encode(n)}${f}`}function f(t,n=90){k("bech32.decode input",t);const r=t.length;if(r<8||!1!==n&&r>n)throw new TypeError(`invalid string length: ${r} (${t}). Expected (8..${n})`);const o=t.toLowerCase();if(t!==o&&t!==t.toUpperCase())throw new Error("String must be lowercase or uppercase");const i=o.lastIndexOf("1");if(0===i||-1===i)throw new Error('Letter "1" must be present between prefix and data only');const s=o.slice(0,i),f=o.slice(i+1);if(f.length<6)throw new Error("Data must be at least 6 characters long");const c=W.decode(f).slice(0,-6),u=J(s,c,e);if(!f.endsWith(u))throw new Error(`Invalid checksum in ${t}: expected "${u}"`);return{prefix:s,words:c}}return{encode:s,decode:f,encodeFromBytes:function(t,e){return s(t,o(e))},decodeToBytes:function(t){const{prefix:e,words:n}=f(t,!1);return{prefix:e,words:n,bytes:r(n)}},decodeUnsafe:V(f),fromWords:r,fromWordsUnsafe:i,toWords:o}}const Q=X("bech32"),tt=X("bech32m"),et=t=>K(y).encode(t),nt=t=>K(y).decode(t),rt=t=>F.encode(t),ot=t=>F.decode(t),it=t=>D.encode(t),st=t=>D.decode(t),ft={to_words:Q.toWords,to_bytes:Q.fromWords,encode:(t,e,n=!1)=>Q.encode(t,e,n),decode:(t,e=!1)=>{const{prefix:n,words:r}=Q.decode(t,e);return{prefix:n,words:r}}},ct={to_words:tt.toWords,to_bytes:tt.fromWords,encode:(t,e,n=!1)=>tt.encode(t,e,n),decode:(t,e=!1)=>{const{prefix:n,words:r}=tt.decode(t,e);return{prefix:n,words:r}}},ut=BigInt(0),at=BigInt(255),ht=BigInt(256);function dt(t,e,n="be"){void 0===e&&(e=function(t){if(t<=0xffn)return 1;if(t<=0xffffn)return 2;if(t<=0xffffffffn)return 4;if(t<=0xffffffffffffffffn)return 8;if(t<=0xffffffffffffffffffffffffffffffffn)return 16;if(t<=0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffn)return 32;throw new TypeError("Must specify a fixed buffer size for bigints greater than 32 bytes.")}(t));const r="le"===n,o=new ArrayBuffer(e),i=new DataView(o);let s=r?0:e-1;for(;t>ut;){const e=t&at,n=Number(e);r?i.setUint8(s++,n):i.setUint8(s--,n),t=(t-e)/ht}return new Uint8Array(o)}function lt(t,e,n="be"){void 0===e&&(e=function(t){if(t<=255)return 1;if(t<=65535)return 2;if(t<=4294967295)return 4;throw new TypeError("Numbers larger than 4 bytes must specify a fixed size!")}(t));const r="le"===n,o=new ArrayBuffer(e),i=new DataView(o);let s=r?0:e-1;for(;t>0;){const e=255&t;r?i.setUint8(s++,t):i.setUint8(s--,t),t=(t-e)/256}return new Uint8Array(o)}function gt(t){return null===t.match(/[^a-fA-F0-9]/)&&t.length%2==0}function wt(t){return!("string"!=typeof t||!gt(t))||("number"==typeof t||"bigint"==typeof t||t instanceof Uint8Array||!(!Array.isArray(t)||!t.every((t=>"number"==typeof t))))}function pt(t,e,n="be"){void 0===e&&(e=t.length),function(t,e){if(t.length>e)throw new TypeError(`Data is larger than array size: ${t.length} > ${e}`)}(t,e);const r=new Uint8Array(e).fill(0),o="be"===n?0:e-t.length;return r.set(t,o),r}function yt(t){let e,n=0;const r=t.reduce(((t,e)=>t+e.length),0),o=new Uint8Array(r);for(e=0;e<t.length;e++){const r=t[e];o.set(r,n),n+=r.length}return o}function bt(t,e){return"bigint"==typeof e?`${e}n`:e}function mt(t,e){return"string"==typeof e&&/^[0-9]+n$/.test(e)?BigInt(e.slice(0,-1)):e}function Et(t,e,n){if(t instanceof ArrayBuffer)return new Uint8Array(t);if(t instanceof Uint8Array)return pt(t,e,n);if(Array.isArray(t)){return yt(t.map((t=>Et(t,e,n))))}if("string"==typeof t)return function(t,e,n="le"){e=B(t,e);const r="le"===n,o=new ArrayBuffer(e),i=new DataView(o);let s=r?0:e-1;for(let e=0;e<t.length;e+=2){const n=t.substring(e,e+2),o=parseInt(n,16);r?i.setUint8(s++,o):i.setUint8(s--,o)}return new Uint8Array(o)}(t,e,n);if("bigint"==typeof t)return dt(t,e,n);if("number"==typeof t)return lt(t,e,n);if("boolean"==typeof t)return Uint8Array.of(t?1:0);throw new TypeError("Unsupported format:"+String(typeof t))}class xt extends Uint8Array{static{this.num=vt}static{this.big=Bt}static{this.bin=_t}static{this.raw=At}static{this.str=It}static{this.hex=St}static{this.bytes=qt}static{this.json=kt}static{this.base64=Ut}static{this.b64url=Ot}static{this.bech32=Nt}static{this.bech32m=Rt}static{this.b58chk=Tt}static{this.encode=v}static{this.decode=_}static{this.parse=Lt}static{this.is_bytes=wt}static{this.is_hex=gt}static{this.is_equal=zt}static random(t=32){const e=a(t);return new xt(e,t)}static now(t=4){const e=Math.floor(Date.now()/1e3);return new xt(e,t)}constructor(t,e,n){if(t instanceof xt&&void 0===e)return t;super(Et(t,e,n))}get arr(){return[...this]}get num(){return this.to_num()}get big(){return this.to_big()}get str(){return this.to_str()}get hex(){return this.to_hex()}get raw(){return new Uint8Array(this)}get bin(){return this.to_bin()}get b58chk(){return this.to_b58chk()}get base64(){return this.to_base64()}get b64url(){return this.to_b64url()}get digest(){return this.to_hash()}get id(){return this.to_hash().hex}get stream(){return new Ht(this)}to_num(t="be"){return function(t){let e=0;for(let n=t.length-1;n>=0;n--)e=256*e+t[n],b(e);return e}("be"===t?this.reverse():this)}to_big(t="be"){return function(t){let e=BigInt(0);for(let n=t.length-1;n>=0;n--)e=e*ht+BigInt(t[n]);return BigInt(e)}("be"===t?this.reverse():this)}to_bin(){return function(t){const e=new Array(8*t.length);let n=0;for(const r of t){if(r>255)throw new Error(`Invalid byte value: ${r}. Byte values must be between 0 and 255.`);for(let t=7;t>=0;t--,n++)e[n]=r>>t&1}return e.join("")}(this)}to_hash(){const t=y(this);return new xt(t)}to_json(t){void 0===t&&(t=mt);const e=_(this);return JSON.parse(e,t)}to_bech32(t,e){const{encode:n,to_words:r}=ft;return n(t,r(this),e)}to_bech32m(t,e){const{encode:n,to_words:r}=ct;return n(t,r(this),e)}to_str(){return _(this)}to_hex(){return function(t){let e="";for(let n=0;n<t.length;n++)e+=t[n].toString(16).padStart(2,"0");return e}(this)}to_bytes(){return new Uint8Array(this)}to_b58chk(){return et(this)}to_base64(){return rt(this)}to_b64url(){return it(this)}append(t){return xt.join([this,xt.bytes(t)])}equals(t){return qt(t).hex===this.hex}prepend(t){return xt.join([xt.bytes(t),this])}reverse(){const t=new Uint8Array(this).reverse();return new xt(t)}slice(t,e){const n=new Uint8Array(this).slice(t,e);return new xt(n)}set(t,e){this.set(t,e)}subarray(t,e){const n=new Uint8Array(this).subarray(t,e);return new xt(n)}write(t,e){const n=xt.bytes(t);this.set(n,e)}add_varint(t){const e=xt.calc_varint(this.length,t);return xt.join([e,this])}toJSON(){return this.hex}toString(){return this.hex}static from(t){return new xt(Uint8Array.from(t))}static of(...t){return new xt(Uint8Array.of(...t))}static join(t){const e=yt(t.map((t=>xt.bytes(t))));return new xt(e)}static sort(t,e){const n=t.map((t=>qt(t,e).hex));return n.sort(),n.map((t=>xt.hex(t,e)))}static calc_varint(t,e){if(t<253)return xt.num(t,1);if(t<65536)return xt.of(253,...xt.num(t,2,e));if(t<4294967296)return xt.of(254,...xt.num(t,4,e));if(BigInt(t)<0x10000000000000000n)return xt.of(255,...xt.num(t,8,e));throw new Error(`Value is too large: ${t}`)}}function vt(t,e,n){return new xt(t,e,n)}function _t(t,e,n){return new xt(function(t){const e=t.split("").map(Number);if(e.length%8!=0)throw new Error(`Binary array is invalid length: ${t.length}`);const n=new Uint8Array(e.length/8);for(let t=0,r=0;t<e.length;t+=8,r++){let o=0;for(let n=0;n<8;n++)o|=e[t+n]<<7-n;n[r]=o}return n}(t),e,n)}function Bt(t,e,n){return new xt(t,e,n)}function At(t,e,n){return new xt(t,e,n)}function It(t,e,n){return new xt(v(t),e,n)}function St(t,e,n){return new xt(t,e,n)}function kt(t,e){void 0===e&&(e=bt);const n=JSON.stringify(t,e);return new xt(v(n))}function Ut(t){return new xt(ot(t))}function Ot(t){return new xt(st(t))}function Nt(t,e,n){const{decode:r,to_bytes:o}=ft,{prefix:i,words:s}=r(t,e),f=o(s);return"string"==typeof n&&m(i,n),new xt(f)}function Rt(t,e,n){const{decode:r,to_bytes:o}=ct,{prefix:i,words:s}=r(t,e),f=o(s);return"string"==typeof n&&m(i,n),new xt(f)}function Tt(t){return new xt(nt(t))}function Lt(t,e,n){const r=function(t,e,n){const r=t.length,o=n/e;if(n%e!=0)throw new TypeError(`Invalid parameters: ${n} % ${e} !== 0`);if(r!==n)throw new TypeError(`Invalid data stream: ${r} !== ${n}`);if(r%e!=0)throw new TypeError(`Invalid data stream: ${r} % ${e} !== 0`);const i=new Array(o);for(let n=0;n<o;n++){const r=n*e;i[n]=t.subarray(r,r+e)}return i}(Et(t),e,n);return r.map((t=>xt.bytes(t)))}function zt(t,e){return new xt(t).hex===new xt(e).hex}function qt(t,e,n){return new xt(t,e,n)}class Ht{constructor(t){this.data=xt.bytes(t),this.size=this.data.length}peek(t){if(t>this.size)throw new Error(`Size greater than stream: ${t} > ${this.size}`);return new xt(this.data.slice(0,t))}read(t){const e=this.peek(t);return this.data=this.data.slice(t),this.size=this.data.length,e}read_varint(t){const e=this.read(1).num;switch(!0){case e>=0&&e<253:return e;case 253===e:return this.read(2).to_num(t);case 254===e:return this.read(4).to_num(t);case 255===e:return this.read(8).to_num(t);default:throw new Error(`Varint is out of range: ${e}`)}}}class $t extends c{constructor(t,n){super(),this.finished=!1,this.destroyed=!1,function(t){if("function"!=typeof t||"function"!=typeof t.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");e(t.outputLen),e(t.blockLen)}(t);const r=f(n);if(this.iHash=t.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(r.length>o?t.create().update(r).digest():r);for(let t=0;t<i.length;t++)i[t]^=54;this.iHash.update(i),this.oHash=t.create();for(let t=0;t<i.length;t++)i[t]^=106;this.oHash.update(i),i.fill(0)}update(t){return r(this),this.iHash.update(t),this}digestInto(t){r(this),n(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:n,finished:r,destroyed:o,blockLen:i,outputLen:s}=this;return t.finished=r,t.destroyed=o,t.blockLen=i,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=n._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const Pt=(t,e,n)=>new $t(t,e).update(n).digest();Pt.create=(t,e)=>new $t(t,e)
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */;const jt=BigInt(0),Ct=BigInt(1),Vt=BigInt(2);function Ft(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function Dt(t){if(!Ft(t))throw new Error("Uint8Array expected")}function Zt(t,e){if("boolean"!=typeof e)throw new Error(t+" boolean expected, got "+e)}const Mt=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function Kt(t){Dt(t);let e="";for(let n=0;n<t.length;n++)e+=Mt[t[n]];return e}function Wt(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function Yt(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);return""===t?jt:BigInt("0x"+t)}const Gt=48,Jt=57,Xt=65,Qt=70,te=97,ee=102;function ne(t){return t>=Gt&&t<=Jt?t-Gt:t>=Xt&&t<=Qt?t-(Xt-10):t>=te&&t<=ee?t-(te-10):void 0}function re(t){if("string"!=typeof t)throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let e=0,o=0;e<n;e++,o+=2){const n=ne(t.charCodeAt(o)),i=ne(t.charCodeAt(o+1));if(void 0===n||void 0===i){const e=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+e+'" at index '+o)}r[e]=16*n+i}return r}function oe(t){return Yt(Kt(t))}function ie(t){return Dt(t),Yt(Kt(Uint8Array.from(t).reverse()))}function se(t,e){return re(t.toString(16).padStart(2*e,"0"))}function fe(t,e){return se(t,e).reverse()}function ce(t,e,n){let r;if("string"==typeof e)try{r=re(e)}catch(e){throw new Error(t+" must be hex string or Uint8Array, cause: "+e)}else{if(!Ft(e))throw new Error(t+" must be hex string or Uint8Array");r=Uint8Array.from(e)}const o=r.length;if("number"==typeof n&&o!==n)throw new Error(t+" of length "+n+" expected, got "+o);return r}function ue(...t){let e=0;for(let n=0;n<t.length;n++){const r=t[n];Dt(r),e+=r.length}const n=new Uint8Array(e);for(let e=0,r=0;e<t.length;e++){const o=t[e];n.set(o,r),r+=o.length}return n}function ae(t){if("string"!=typeof t)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(t))}const he=t=>"bigint"==typeof t&&jt<=t;function de(t,e,n){return he(t)&&he(e)&&he(n)&&e<=t&&t<n}function le(t,e,n,r){if(!de(e,n,r))throw new Error("expected valid "+t+": "+n+" <= n < "+r+", got "+e)}function ge(t){let e;for(e=0;t>jt;t>>=Ct,e+=1);return e}const we=t=>(Vt<<BigInt(t-1))-Ct,pe=t=>new Uint8Array(t),ye=t=>Uint8Array.from(t);function be(t,e,n){if("number"!=typeof t||t<2)throw new Error("hashLen must be a number");if("number"!=typeof e||e<2)throw new Error("qByteLen must be a number");if("function"!=typeof n)throw new Error("hmacFn must be a function");let r=pe(t),o=pe(t),i=0;const s=()=>{r.fill(1),o.fill(0),i=0},f=(...t)=>n(o,r,...t),c=(t=pe())=>{o=f(ye([0]),t),r=f(),0!==t.length&&(o=f(ye([1]),t),r=f())},u=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let t=0;const n=[];for(;t<e;){r=f();const e=r.slice();n.push(e),t+=r.length}return ue(...n)};return(t,e)=>{let n;for(s(),c(t);!(n=e(u()));)c();return s(),n}}const me={bigint:t=>"bigint"==typeof t,function:t=>"function"==typeof t,boolean:t=>"boolean"==typeof t,string:t=>"string"==typeof t,stringOrUint8Array:t=>"string"==typeof t||Ft(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>"function"==typeof t&&Number.isSafeInteger(t.outputLen)};function Ee(t,e,n={}){const r=(e,n,r)=>{const o=me[n];if("function"!=typeof o)throw new Error("invalid validator function");const i=t[e];if(!(r&&void 0===i||o(i,t)))throw new Error("param "+String(e)+" is invalid. Expected "+n+", got "+i)};for(const[t,n]of Object.entries(e))r(t,n,!1);for(const[t,e]of Object.entries(n))r(t,e,!0);return t}function xe(t){const e=new WeakMap;return(n,...r)=>{const o=e.get(n);if(void 0!==o)return o;const i=t(n,...r);return e.set(n,i),i}}var ve=Object.freeze({__proto__:null,aInRange:le,abool:Zt,abytes:Dt,bitGet:function(t,e){return t>>BigInt(e)&Ct},bitLen:ge,bitMask:we,bitSet:function(t,e,n){return t|(n?Ct:jt)<<BigInt(e)},bytesToHex:Kt,bytesToNumberBE:oe,bytesToNumberLE:ie,concatBytes:ue,createHmacDrbg:be,ensureBytes:ce,equalBytes:function(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return 0===n},hexToBytes:re,hexToNumber:Yt,inRange:de,isBytes:Ft,memoized:xe,notImplemented:()=>{throw new Error("not implemented")},numberToBytesBE:se,numberToBytesLE:fe,numberToHexUnpadded:Wt,numberToVarBytesBE:function(t){return re(Wt(t))},utf8ToBytes:ae,validateObject:Ee});
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _e=BigInt(0),Be=BigInt(1),Ae=BigInt(2),Ie=BigInt(3),Se=BigInt(4),ke=BigInt(5),Ue=BigInt(8);function Oe(t,e){const n=t%e;return n>=_e?n:e+n}function Ne(t,e,n){if(e<_e)throw new Error("invalid exponent, negatives unsupported");if(n<=_e)throw new Error("invalid modulus");if(n===Be)return _e;let r=Be;for(;e>_e;)e&Be&&(r=r*t%n),t=t*t%n,e>>=Be;return r}function Re(t,e,n){let r=t;for(;e-- >_e;)r*=r,r%=n;return r}function Te(t,e){if(t===_e)throw new Error("invert: expected non-zero number");if(e<=_e)throw new Error("invert: expected positive modulus, got "+e);let n=Oe(t,e),r=e,o=_e,i=Be;for(;n!==_e;){const t=r%n,e=o-i*(r/n);r=n,n=t,o=i,i=e}if(r!==Be)throw new Error("invert: does not exist");return Oe(o,e)}function Le(t){if(t%Se===Ie){const e=(t+Be)/Se;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}}if(t%Ue===ke){const e=(t-ke)/Ue;return function(t,n){const r=t.mul(n,Ae),o=t.pow(r,e),i=t.mul(n,o),s=t.mul(t.mul(i,Ae),o),f=t.mul(i,t.sub(s,t.ONE));if(!t.eql(t.sqr(f),n))throw new Error("Cannot find square root");return f}}return function(t){const e=(t-Be)/Ae;let n,r,o;for(n=t-Be,r=0;n%Ae===_e;n/=Ae,r++);for(o=Ae;o<t&&Ne(o,e,t)!==t-Be;o++)if(o>1e3)throw new Error("Cannot find square root: likely non-prime P");if(1===r){const e=(t+Be)/Se;return function(t,n){const r=t.pow(n,e);if(!t.eql(t.sqr(r),n))throw new Error("Cannot find square root");return r}}const i=(n+Be)/Ae;return function(t,s){if(t.pow(s,e)===t.neg(t.ONE))throw new Error("Cannot find square root");let f=r,c=t.pow(t.mul(t.ONE,o),n),u=t.pow(s,i),a=t.pow(s,n);for(;!t.eql(a,t.ONE);){if(t.eql(a,t.ZERO))return t.ZERO;let e=1;for(let n=t.sqr(a);e<f&&!t.eql(n,t.ONE);e++)n=t.sqr(n);const n=t.pow(c,Be<<BigInt(f-e-1));c=t.sqr(n),u=t.mul(u,n),a=t.mul(a,c),f=e}return u}}(t)}const ze=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function qe(t,e){const n=void 0!==e?e:t.toString(2).length;return{nBitLength:n,nByteLength:Math.ceil(n/8)}}function He(t,e,n=!1,r={}){if(t<=_e)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:o,nByteLength:i}=qe(t,e);if(i>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let s;const f=Object.freeze({ORDER:t,isLE:n,BITS:o,BYTES:i,MASK:we(o),ZERO:_e,ONE:Be,create:e=>Oe(e,t),isValid:e=>{if("bigint"!=typeof e)throw new Error("invalid field element: expected bigint, got "+typeof e);return _e<=e&&e<t},is0:t=>t===_e,isOdd:t=>(t&Be)===Be,neg:e=>Oe(-e,t),eql:(t,e)=>t===e,sqr:e=>Oe(e*e,t),add:(e,n)=>Oe(e+n,t),sub:(e,n)=>Oe(e-n,t),mul:(e,n)=>Oe(e*n,t),pow:(t,e)=>function(t,e,n){if(n<_e)throw new Error("invalid exponent, negatives unsupported");if(n===_e)return t.ONE;if(n===Be)return e;let r=t.ONE,o=e;for(;n>_e;)n&Be&&(r=t.mul(r,o)),o=t.sqr(o),n>>=Be;return r}(f,t,e),div:(e,n)=>Oe(e*Te(n,t),t),sqrN:t=>t*t,addN:(t,e)=>t+e,subN:(t,e)=>t-e,mulN:(t,e)=>t*e,inv:e=>Te(e,t),sqrt:r.sqrt||(e=>(s||(s=Le(t)),s(f,e))),invertBatch:t=>function(t,e){const n=new Array(e.length),r=e.reduce(((e,r,o)=>t.is0(r)?e:(n[o]=e,t.mul(e,r))),t.ONE),o=t.inv(r);return e.reduceRight(((e,r,o)=>t.is0(r)?e:(n[o]=t.mul(e,n[o]),t.mul(e,r))),o),n}(f,t),cmov:(t,e,n)=>n?e:t,toBytes:t=>n?fe(t,i):se(t,i),fromBytes:t=>{if(t.length!==i)throw new Error("Field.fromBytes: expected "+i+" bytes, got "+t.length);return n?ie(t):oe(t)}});return Object.freeze(f)}function $e(t){if("bigint"!=typeof t)throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function Pe(t){const e=$e(t);return e+Math.ceil(e/2)}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const je=BigInt(0),Ce=BigInt(1);function Ve(t,e){const n=e.negate();return t?n:e}function Fe(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function De(t,e){Fe(t,e);return{windows:Math.ceil(e/t)+1,windowSize:2**(t-1)}}const Ze=new WeakMap,Me=new WeakMap;function Ke(t){return Me.get(t)||1}function We(t,e,n,r){if(function(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach(((t,n)=>{if(!(t instanceof e))throw new Error("invalid point at index "+n)}))}(n,t),function(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach(((t,n)=>{if(!e.isValid(t))throw new Error("invalid scalar at index "+n)}))}(r,e),n.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const o=t.ZERO,i=ge(BigInt(n.length)),s=i>12?i-3:i>4?i-2:i?2:1,f=(1<<s)-1,c=new Array(f+1).fill(o);let u=o;for(let t=Math.floor((e.BITS-1)/s)*s;t>=0;t-=s){c.fill(o);for(let e=0;e<r.length;e++){const o=r[e],i=Number(o>>BigInt(t)&BigInt(f));c[i]=c[i].add(n[e])}let e=o;for(let t=c.length-1,n=o;t>0;t--)n=n.add(c[t]),e=e.add(n);if(u=u.add(e),0!==t)for(let t=0;t<s;t++)u=u.double()}return u}function Ye(t){return Ee(t.Fp,ze.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),Ee(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...qe(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function Ge(t){void 0!==t.lowS&&Zt("lowS",t.lowS),void 0!==t.prehash&&Zt("prehash",t.prehash)}const{bytesToNumberBE:Je,hexToBytes:Xe}=ve;class Qe extends Error{constructor(t=""){super(t)}}const tn={Err:Qe,_tlv:{encode:(t,e)=>{const{Err:n}=tn;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(1&e.length)throw new n("tlv.encode: unpadded data");const r=e.length/2,o=Wt(r);if(o.length/2&128)throw new n("tlv.encode: long form length too big");const i=r>127?Wt(o.length/2|128):"";return Wt(t)+i+o+e},decode(t,e){const{Err:n}=tn;let r=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length<2||e[r++]!==t)throw new n("tlv.decode: wrong tlv");const o=e[r++];let i=0;if(!!(128&o)){const t=127&o;if(!t)throw new n("tlv.decode(long): indefinite length not supported");if(t>4)throw new n("tlv.decode(long): byte length is too big");const s=e.subarray(r,r+t);if(s.length!==t)throw new n("tlv.decode: length bytes not complete");if(0===s[0])throw new n("tlv.decode(long): zero leftmost byte");for(const t of s)i=i<<8|t;if(r+=t,i<128)throw new n("tlv.decode(long): not minimal encoding")}else i=o;const s=e.subarray(r,r+i);if(s.length!==i)throw new n("tlv.decode: wrong value length");return{v:s,l:e.subarray(r+i)}}},_int:{encode(t){const{Err:e}=tn;if(t<en)throw new e("integer: negative integers are not allowed");let n=Wt(t);if(8&Number.parseInt(n[0],16)&&(n="00"+n),1&n.length)throw new e("unexpected DER parsing assertion: unpadded hex");return n},decode(t){const{Err:e}=tn;if(128&t[0])throw new e("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new e("invalid signature integer: unnecessary leading zero");return Je(t)}},toSig(t){const{Err:e,_int:n,_tlv:r}=tn,o="string"==typeof t?Xe(t):t;Dt(o);const{v:i,l:s}=r.decode(48,o);if(s.length)throw new e("invalid signature: left bytes after parsing");const{v:f,l:c}=r.decode(2,i),{v:u,l:a}=r.decode(2,c);if(a.length)throw new e("invalid signature: left bytes after parsing");return{r:n.decode(f),s:n.decode(u)}},hexFromSig(t){const{_tlv:e,_int:n}=tn,r=e.encode(2,n.encode(t.r))+e.encode(2,n.encode(t.s));return e.encode(48,r)}},en=BigInt(0),nn=BigInt(1);BigInt(2);const rn=BigInt(3);function on(t){const e=function(t){const e=Ye(t);Ee(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:o}=e;if(n){if(!r.eql(o,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if("object"!=typeof n||"bigint"!=typeof n.beta||"function"!=typeof n.splitScalar)throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:n}=e,r=He(e.n,e.nBitLength),o=e.toBytes||((t,e,r)=>{const o=e.toAffine();return ue(Uint8Array.from([4]),n.toBytes(o.x),n.toBytes(o.y))}),i=e.fromBytes||(t=>{const e=t.subarray(1);return{x:n.fromBytes(e.subarray(0,n.BYTES)),y:n.fromBytes(e.subarray(n.BYTES,2*n.BYTES))}});function s(t){const{a:r,b:o}=e,i=n.sqr(t),s=n.mul(i,t);return n.add(n.add(s,n.mul(t,r)),o)}if(!n.eql(n.sqr(e.Gy),s(e.Gx)))throw new Error("bad generator point: equation left != right");function f(t){const{allowedPrivateKeyLengths:n,nByteLength:r,wrapPrivateKey:o,n:i}=e;if(n&&"bigint"!=typeof t){if(Ft(t)&&(t=Kt(t)),"string"!=typeof t||!n.includes(t.length))throw new Error("invalid private key");t=t.padStart(2*r,"0")}let s;try{s="bigint"==typeof t?t:oe(ce("private key",t,r))}catch(e){throw new Error("invalid private key, expected hex or "+r+" bytes, got "+typeof t)}return o&&(s=Oe(s,i)),le("private key",s,nn,i),s}function c(t){if(!(t instanceof h))throw new Error("ProjectivePoint expected")}const u=xe(((t,e)=>{const{px:r,py:o,pz:i}=t;if(n.eql(i,n.ONE))return{x:r,y:o};const s=t.is0();null==e&&(e=s?n.ONE:n.inv(i));const f=n.mul(r,e),c=n.mul(o,e),u=n.mul(i,e);if(s)return{x:n.ZERO,y:n.ZERO};if(!n.eql(u,n.ONE))throw new Error("invZ was invalid");return{x:f,y:c}})),a=xe((t=>{if(t.is0()){if(e.allowInfinityPoint&&!n.is0(t.py))return;throw new Error("bad point: ZERO")}const{x:r,y:o}=t.toAffine();if(!n.isValid(r)||!n.isValid(o))throw new Error("bad point: x or y not FE");const i=n.sqr(o),f=s(r);if(!n.eql(i,f))throw new Error("bad point: equation left != right");if(!t.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0}));class h{constructor(t,e,r){if(this.px=t,this.py=e,this.pz=r,null==t||!n.isValid(t))throw new Error("x required");if(null==e||!n.isValid(e))throw new Error("y required");if(null==r||!n.isValid(r))throw new Error("z required");Object.freeze(this)}static fromAffine(t){const{x:e,y:r}=t||{};if(!t||!n.isValid(e)||!n.isValid(r))throw new Error("invalid affine point");if(t instanceof h)throw new Error("projective point not allowed");const o=t=>n.eql(t,n.ZERO);return o(e)&&o(r)?h.ZERO:new h(e,r,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=n.invertBatch(t.map((t=>t.pz)));return t.map(((t,n)=>t.toAffine(e[n]))).map(h.fromAffine)}static fromHex(t){const e=h.fromAffine(i(ce("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return h.BASE.multiply(f(t))}static msm(t,e){return We(h,r,t,e)}_setWindowSize(t){l.setWindowSize(this,t)}assertValidity(){a(this)}hasEvenY(){const{y:t}=this.toAffine();if(n.isOdd)return!n.isOdd(t);throw new Error("Field doesn't support isOdd")}equals(t){c(t);const{px:e,py:r,pz:o}=this,{px:i,py:s,pz:f}=t,u=n.eql(n.mul(e,f),n.mul(i,o)),a=n.eql(n.mul(r,f),n.mul(s,o));return u&&a}negate(){return new h(this.px,n.neg(this.py),this.pz)}double(){const{a:t,b:r}=e,o=n.mul(r,rn),{px:i,py:s,pz:f}=this;let c=n.ZERO,u=n.ZERO,a=n.ZERO,d=n.mul(i,i),l=n.mul(s,s),g=n.mul(f,f),w=n.mul(i,s);return w=n.add(w,w),a=n.mul(i,f),a=n.add(a,a),c=n.mul(t,a),u=n.mul(o,g),u=n.add(c,u),c=n.sub(l,u),u=n.add(l,u),u=n.mul(c,u),c=n.mul(w,c),a=n.mul(o,a),g=n.mul(t,g),w=n.sub(d,g),w=n.mul(t,w),w=n.add(w,a),a=n.add(d,d),d=n.add(a,d),d=n.add(d,g),d=n.mul(d,w),u=n.add(u,d),g=n.mul(s,f),g=n.add(g,g),d=n.mul(g,w),c=n.sub(c,d),a=n.mul(g,l),a=n.add(a,a),a=n.add(a,a),new h(c,u,a)}add(t){c(t);const{px:r,py:o,pz:i}=this,{px:s,py:f,pz:u}=t;let a=n.ZERO,d=n.ZERO,l=n.ZERO;const g=e.a,w=n.mul(e.b,rn);let p=n.mul(r,s),y=n.mul(o,f),b=n.mul(i,u),m=n.add(r,o),E=n.add(s,f);m=n.mul(m,E),E=n.add(p,y),m=n.sub(m,E),E=n.add(r,i);let x=n.add(s,u);return E=n.mul(E,x),x=n.add(p,b),E=n.sub(E,x),x=n.add(o,i),a=n.add(f,u),x=n.mul(x,a),a=n.add(y,b),x=n.sub(x,a),l=n.mul(g,E),a=n.mul(w,b),l=n.add(a,l),a=n.sub(y,l),l=n.add(y,l),d=n.mul(a,l),y=n.add(p,p),y=n.add(y,p),b=n.mul(g,b),E=n.mul(w,E),y=n.add(y,b),b=n.sub(p,b),b=n.mul(g,b),E=n.add(E,b),p=n.mul(y,E),d=n.add(d,p),p=n.mul(x,E),a=n.mul(m,a),a=n.sub(a,p),p=n.mul(m,y),l=n.mul(x,l),l=n.add(l,p),new h(a,d,l)}subtract(t){return this.add(t.negate())}is0(){return this.equals(h.ZERO)}wNAF(t){return l.wNAFCached(this,t,h.normalizeZ)}multiplyUnsafe(t){const{endo:r,n:o}=e;le("scalar",t,en,o);const i=h.ZERO;if(t===en)return i;if(this.is0()||t===nn)return this;if(!r||l.hasPrecomputes(this))return l.wNAFCachedUnsafe(this,t,h.normalizeZ);let{k1neg:s,k1:f,k2neg:c,k2:u}=r.splitScalar(t),a=i,d=i,g=this;for(;f>en||u>en;)f&nn&&(a=a.add(g)),u&nn&&(d=d.add(g)),g=g.double(),f>>=nn,u>>=nn;return s&&(a=a.negate()),c&&(d=d.negate()),d=new h(n.mul(d.px,r.beta),d.py,d.pz),a.add(d)}multiply(t){const{endo:r,n:o}=e;let i,s;if(le("scalar",t,nn,o),r){const{k1neg:e,k1:o,k2neg:f,k2:c}=r.splitScalar(t);let{p:u,f:a}=this.wNAF(o),{p:d,f:g}=this.wNAF(c);u=l.constTimeNegate(e,u),d=l.constTimeNegate(f,d),d=new h(n.mul(d.px,r.beta),d.py,d.pz),i=u.add(d),s=a.add(g)}else{const{p:e,f:n}=this.wNAF(t);i=e,s=n}return h.normalizeZ([i,s])[0]}multiplyAndAddUnsafe(t,e,n){const r=h.BASE,o=(t,e)=>e!==en&&e!==nn&&t.equals(r)?t.multiply(e):t.multiplyUnsafe(e),i=o(this,e).add(o(t,n));return i.is0()?void 0:i}toAffine(t){return u(this,t)}isTorsionFree(){const{h:t,isTorsionFree:n}=e;if(t===nn)return!0;if(n)return n(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:n}=e;return t===nn?this:n?n(h,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return Zt("isCompressed",t),this.assertValidity(),o(h,this,t)}toHex(t=!0){return Zt("isCompressed",t),Kt(this.toRawBytes(t))}}h.BASE=new h(e.Gx,e.Gy,n.ONE),h.ZERO=new h(n.ZERO,n.ONE,n.ZERO);const d=e.nBitLength,l=(g=h,w=e.endo?Math.ceil(d/2):d,{constTimeNegate:Ve,hasPrecomputes:t=>1!==Ke(t),unsafeLadder(t,e,n=g.ZERO){let r=t;for(;e>je;)e&Ce&&(n=n.add(r)),r=r.double(),e>>=Ce;return n},precomputeWindow(t,e){const{windows:n,windowSize:r}=De(e,w),o=[];let i=t,s=i;for(let t=0;t<n;t++){s=i,o.push(s);for(let t=1;t<r;t++)s=s.add(i),o.push(s);i=s.double()}return o},wNAF(t,e,n){const{windows:r,windowSize:o}=De(t,w);let i=g.ZERO,s=g.BASE;const f=BigInt(2**t-1),c=2**t,u=BigInt(t);for(let t=0;t<r;t++){const r=t*o;let a=Number(n&f);n>>=u,a>o&&(a-=c,n+=Ce);const h=r,d=r+Math.abs(a)-1,l=t%2!=0,g=a<0;0===a?s=s.add(Ve(l,e[h])):i=i.add(Ve(g,e[d]))}return{p:i,f:s}},wNAFUnsafe(t,e,n,r=g.ZERO){const{windows:o,windowSize:i}=De(t,w),s=BigInt(2**t-1),f=2**t,c=BigInt(t);for(let t=0;t<o;t++){const o=t*i;if(n===je)break;let u=Number(n&s);if(n>>=c,u>i&&(u-=f,n+=Ce),0===u)continue;let a=e[o+Math.abs(u)-1];u<0&&(a=a.negate()),r=r.add(a)}return r},getPrecomputes(t,e,n){let r=Ze.get(e);return r||(r=this.precomputeWindow(e,t),1!==t&&Ze.set(e,n(r))),r},wNAFCached(t,e,n){const r=Ke(t);return this.wNAF(r,this.getPrecomputes(r,t,n),e)},wNAFCachedUnsafe(t,e,n,r){const o=Ke(t);return 1===o?this.unsafeLadder(t,e,r):this.wNAFUnsafe(o,this.getPrecomputes(o,t,n),e,r)},setWindowSize(t,e){Fe(e,w),Me.set(t,e),Ze.delete(t)}});var g,w;return{CURVE:e,ProjectivePoint:h,normPrivateKeyToScalar:f,weierstrassEquation:s,isWithinCurveOrder:function(t){return de(t,nn,e.n)}}}function sn(t){const e=function(t){const e=Ye(t);return Ee(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:n,n:r}=e,o=n.BYTES+1,i=2*n.BYTES+1;function s(t){return Oe(t,r)}function f(t){return Te(t,r)}const{ProjectivePoint:c,normPrivateKeyToScalar:u,weierstrassEquation:a,isWithinCurveOrder:h}=on({...e,toBytes(t,e,r){const o=e.toAffine(),i=n.toBytes(o.x),s=ue;return Zt("isCompressed",r),r?s(Uint8Array.from([e.hasEvenY()?2:3]),i):s(Uint8Array.from([4]),i,n.toBytes(o.y))},fromBytes(t){const e=t.length,r=t[0],s=t.subarray(1);if(e!==o||2!==r&&3!==r){if(e===i&&4===r){return{x:n.fromBytes(s.subarray(0,n.BYTES)),y:n.fromBytes(s.subarray(n.BYTES,2*n.BYTES))}}throw new Error("invalid Point, expected length of "+o+", or uncompressed "+i+", got "+e)}{const t=oe(s);if(!de(t,nn,n.ORDER))throw new Error("Point is not on curve");const e=a(t);let o;try{o=n.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw new Error("Point is not on curve"+e)}return!(1&~r)!==((o&nn)===nn)&&(o=n.neg(o)),{x:t,y:o}}}}),d=t=>Kt(se(t,e.nByteLength));function l(t){return t>r>>nn}const g=(t,e,n)=>oe(t.slice(e,n));class w{constructor(t,e,n){this.r=t,this.s=e,this.recovery=n,this.assertValidity()}static fromCompact(t){const n=e.nByteLength;return t=ce("compactSignature",t,2*n),new w(g(t,0,n),g(t,n,2*n))}static fromDER(t){const{r:e,s:n}=tn.toSig(ce("DER",t));return new w(e,n)}assertValidity(){le("r",this.r,nn,r),le("s",this.s,nn,r)}addRecoveryBit(t){return new w(this.r,this.s,t)}recoverPublicKey(t){const{r:r,s:o,recovery:i}=this,u=m(ce("msgHash",t));if(null==i||![0,1,2,3].includes(i))throw new Error("recovery id invalid");const a=2===i||3===i?r+e.n:r;if(a>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const h=1&i?"03":"02",l=c.fromHex(h+d(a)),g=f(a),w=s(-u*g),p=s(o*g),y=c.BASE.multiplyAndAddUnsafe(l,w,p);if(!y)throw new Error("point at infinify");return y.assertValidity(),y}hasHighS(){return l(this.s)}normalizeS(){return this.hasHighS()?new w(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return re(this.toDERHex())}toDERHex(){return tn.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return re(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const p={isValidPrivateKey(t){try{return u(t),!0}catch(t){return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const t=Pe(e.n);return function(t,e,n=!1){const r=t.length,o=$e(e),i=Pe(e);if(r<16||r<i||r>1024)throw new Error("expected "+i+"-1024 bytes of input, got "+r);const s=Oe(n?ie(t):oe(t),e-Be)+Be;return n?fe(s,o):se(s,o)}(e.randomBytes(t),e.n)},precompute:(t=8,e=c.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function y(t){const e=Ft(t),n="string"==typeof t,r=(e||n)&&t.length;return e?r===o||r===i:n?r===2*o||r===2*i:t instanceof c}const b=e.bits2int||function(t){if(t.length>8192)throw new Error("input is too large");const n=oe(t),r=8*t.length-e.nBitLength;return r>0?n>>BigInt(r):n},m=e.bits2int_modN||function(t){return s(b(t))},E=we(e.nBitLength);function x(t){return le("num < 2^"+e.nBitLength,t,en,E),se(t,e.nByteLength)}function v(t,r,o=_){if(["recovered","canonical"].some((t=>t in o)))throw new Error("sign() legacy options not supported");const{hash:i,randomBytes:a}=e;let{lowS:d,prehash:g,extraEntropy:p}=o;null==d&&(d=!0),t=ce("msgHash",t),Ge(o),g&&(t=ce("prehashed msgHash",i(t)));const y=m(t),E=u(r),v=[x(E),x(y)];if(null!=p&&!1!==p){const t=!0===p?a(n.BYTES):p;v.push(ce("extraEntropy",t))}const B=ue(...v),A=y;return{seed:B,k2sig:function(t){const e=b(t);if(!h(e))return;const n=f(e),r=c.BASE.multiply(e).toAffine(),o=s(r.x);if(o===en)return;const i=s(n*s(A+o*E));if(i===en)return;let u=(r.x===o?0:2)|Number(r.y&nn),a=i;return d&&l(i)&&(a=function(t){return l(t)?s(-t):t}(i),u^=1),new w(o,a,u)}}}const _={lowS:e.lowS,prehash:!1},B={lowS:e.lowS,prehash:!1};return c.BASE._setWindowSize(8),{CURVE:e,getPublicKey:function(t,e=!0){return c.fromPrivateKey(t).toRawBytes(e)},getSharedSecret:function(t,e,n=!0){if(y(t))throw new Error("first arg must be private key");if(!y(e))throw new Error("second arg must be public key");return c.fromHex(e).multiply(u(t)).toRawBytes(n)},sign:function(t,n,r=_){const{seed:o,k2sig:i}=v(t,n,r),s=e;return be(s.hash.outputLen,s.nByteLength,s.hmac)(o,i)},verify:function(t,n,r,o=B){const i=t;n=ce("msgHash",n),r=ce("publicKey",r);const{lowS:u,prehash:a,format:h}=o;if(Ge(o),"strict"in o)throw new Error("options.strict was renamed to lowS");if(void 0!==h&&"compact"!==h&&"der"!==h)throw new Error("format must be compact or der");const d="string"==typeof i||Ft(i),l=!d&&!h&&"object"==typeof i&&null!==i&&"bigint"==typeof i.r&&"bigint"==typeof i.s;if(!d&&!l)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let g,p;try{if(l&&(g=new w(i.r,i.s)),d){try{"compact"!==h&&(g=w.fromDER(i))}catch(t){if(!(t instanceof tn.Err))throw t}g||"der"===h||(g=w.fromCompact(i))}p=c.fromHex(r)}catch(t){return!1}if(!g)return!1;if(u&&g.hasHighS())return!1;a&&(n=e.hash(n));const{r:y,s:b}=g,E=m(n),x=f(b),v=s(E*x),_=s(y*x),A=c.BASE.multiplyAndAddUnsafe(p,v,_)?.toAffine();return!!A&&s(A.x)===y},ProjectivePoint:c,Signature:w,utils:p}}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function fn(t){return{hash:t,hmac:(e,...r)=>Pt(t,e,function(...t){let e=0;for(let r=0;r<t.length;r++){const o=t[r];n(o),e+=o.length}const r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const o=t[e];r.set(o,n),n+=o.length}return r}(...r)),randomBytes:a}}BigInt(4);const cn=oe;function un(t,e){if(hn(t),hn(e),t<0||t>=1<<8*e)throw new Error("invalid I2OSP input: "+t);const n=Array.from({length:e}).fill(0);for(let r=e-1;r>=0;r--)n[r]=255&t,t>>>=8;return new Uint8Array(n)}function an(t,e){const n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r]^e[r];return n}function hn(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function dn(t,e,n){Ee(n,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:r,k:o,m:i,hash:s,expand:f,DST:c}=n;Dt(t),hn(e);const u="string"==typeof c?ae(c):c,a=r.toString(2).length,h=Math.ceil((a+o)/8),d=e*i*h;let l;if("xmd"===f)l=function(t,e,n,r){Dt(t),Dt(e),hn(n),e.length>255&&(e=r(ue(ae("H2C-OVERSIZE-DST-"),e)));const{outputLen:o,blockLen:i}=r,s=Math.ceil(n/o);if(n>65535||s>255)throw new Error("expand_message_xmd: invalid lenInBytes");const f=ue(e,un(e.length,1)),c=un(0,i),u=un(n,2),a=new Array(s),h=r(ue(c,t,u,un(0,1),f));a[0]=r(ue(h,un(1,1),f));for(let t=1;t<=s;t++){const e=[an(h,a[t-1]),un(t+1,1),f];a[t]=r(ue(...e))}return ue(...a).slice(0,n)}(t,u,d,s);else if("xof"===f)l=function(t,e,n,r,o){if(Dt(t),Dt(e),hn(n),e.length>255){const t=Math.ceil(2*r/8);e=o.create({dkLen:t}).update(ae("H2C-OVERSIZE-DST-")).update(e).digest()}if(n>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return o.create({dkLen:n}).update(t).update(un(n,2)).update(e).update(un(e.length,1)).digest()}(t,u,d,o,s);else{if("_internal_pass"!==f)throw new Error('expand must be "xmd" or "xof"');l=t}const g=new Array(e);for(let t=0;t<e;t++){const e=new Array(i);for(let n=0;n<i;n++){const o=h*(n+t*i),s=l.subarray(o,o+h);e[n]=Oe(cn(s),r)}g[t]=e}return g}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ln=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),gn=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),wn=BigInt(1),pn=BigInt(2),yn=(t,e)=>(t+e/pn)/e;function bn(t){const e=ln,n=BigInt(3),r=BigInt(6),o=BigInt(11),i=BigInt(22),s=BigInt(23),f=BigInt(44),c=BigInt(88),u=t*t*t%e,a=u*u*t%e,h=Re(a,n,e)*a%e,d=Re(h,n,e)*a%e,l=Re(d,pn,e)*u%e,g=Re(l,o,e)*l%e,w=Re(g,i,e)*g%e,p=Re(w,f,e)*w%e,y=Re(p,c,e)*p%e,b=Re(y,f,e)*w%e,m=Re(b,n,e)*a%e,E=Re(m,s,e)*g%e,x=Re(E,r,e)*u%e,v=Re(x,pn,e);if(!mn.eql(mn.sqr(v),t))throw new Error("Cannot find square root");return v}const mn=He(ln,void 0,void 0,{sqrt:bn}),En=function(t,e){const n=e=>sn({...t,...fn(e)});return{...n(e),create:n}}({a:BigInt(0),b:BigInt(7),Fp:mn,n:gn,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=gn,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-wn*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=n,s=BigInt("0x100000000000000000000000000000000"),f=yn(i*t,e),c=yn(-r*t,e);let u=Oe(t-f*n-c*o,e),a=Oe(-f*r-c*i,e);const h=u>s,d=a>s;if(h&&(u=e-u),d&&(a=e-a),u>s||a>s)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:h,k1:u,k2neg:d,k2:a}}}},y),xn=BigInt(0),vn={};function _n(t,...e){let n=vn[t];if(void 0===n){const e=y(Uint8Array.from(t,(t=>t.charCodeAt(0))));n=ue(e,e),vn[t]=n}return y(ue(n,...e))}const Bn=t=>t.toRawBytes(!0).slice(1),An=t=>se(t,32),In=t=>Oe(t,ln),Sn=t=>Oe(t,gn),kn=En.ProjectivePoint;function Un(t){let e=En.utils.normPrivateKeyToScalar(t),n=kn.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:Sn(-e),bytes:Bn(n)}}function On(t){le("x",t,wn,ln);const e=In(t*t);let n=bn(In(e*t+BigInt(7)));n%pn!==xn&&(n=In(-n));const r=new kn(t,n,wn);return r.assertValidity(),r}const Nn=oe;function Rn(...t){return Sn(Nn(_n("BIP0340/challenge",...t)))}function Tn(t){return Un(t).bytes}function Ln(t,e,n=a(32)){const r=ce("message",t),{bytes:o,scalar:i}=Un(e),s=ce("auxRand",n,32),f=An(i^Nn(_n("BIP0340/aux",s))),c=_n("BIP0340/nonce",f,o,r),u=Sn(Nn(c));if(u===xn)throw new Error("sign failed: k is zero");const{bytes:h,scalar:d}=Un(u),l=Rn(h,o,r),g=new Uint8Array(64);if(g.set(h,0),g.set(An(Sn(d+l*i)),32),!zn(g,r,o))throw new Error("sign: Invalid signature produced");return g}function zn(t,e,n){const r=ce("signature",t,64),o=ce("message",e),i=ce("publicKey",n,32);try{const t=On(Nn(i)),e=Nn(r.subarray(0,32));if(!de(e,wn,ln))return!1;const n=Nn(r.subarray(32,64));if(!de(n,wn,gn))return!1;const u=Rn(An(e),Bn(t),o),a=(s=t,f=n,c=Sn(-u),kn.BASE.multiplyAndAddUnsafe(s,f,c));return!(!a||!a.hasEvenY()||a.toAffine().x!==e)}catch(t){return!1}var s,f,c}const qn=(()=>({getPublicKey:Tn,sign:Ln,verify:zn,utils:{randomPrivateKey:En.utils.randomPrivateKey,lift_x:On,pointToBytes:Bn,numberToBytesBE:se,bytesToNumberBE:oe,taggedHash:_n,mod:Oe}}))(),Hn=BigInt(0),$n=BigInt(1),Pn=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),jn=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Cn=En.CURVE,Vn=He(jn,32,!0),Fn=En.ProjectivePoint,Dn="FROST-secp256k1-SHA256-v1";var Zn={_0n:Hn,_1n:$n,_N:jn,_P:Pn,CURVE:Cn,DOMAIN:Dn,FIELD:Vn,POINT:Fn};const{POINT:Mn,_N:Kn}=Zn;function Wn(t){return Oe(t,Kn)}function Yn(t){return(new TextEncoder).encode(t)}function Gn(t){let e=xt.bytes(t);if(e.length<32||e.length>33)throw new Error("invalid pubkeky: "+e.hex+" "+e.length);return 32===e.length&&(e=e.prepend(2)),Mn.fromHex(e.hex)}const Jn={m:1,p:jn,k:128,expand:"xmd",hash:y};function Xn(t){return{...Jn,DST:t}}function Qn(t){const e=dn(t,1,Xn(Dn+"rho"));return xt.big(e[0][0],32)}function tr(t){const e=dn(t,1,Xn(Dn+"nonce"));return xt.big(e[0][0],32)}function er(t){const e=Yn(Dn+"msg"),n=y(new Uint8Array([...e,...t]));return new xt(n)}function nr(t){const e=Yn(Dn+"com"),n=y(new Uint8Array([...e,...t]));return new xt(n)}var rr=Object.freeze({__proto__:null,H1:Qn,H2:function(t){const e=dn(t,1,Xn(Dn+"chal"));return xt.big(e[0][0],32)},H3:tr,H4:er,H5:nr});function or(t,e){if(!1===t)throw new Error(e??"Assertion failed!")}function ir(t){if(void 0===t)throw new TypeError("Input is undefined!");if(null===t)throw new TypeError("Input is null!")}function sr(t,e){const n=xt.bytes(t);if(n.length!==e)throw new Error(`Invalid byte size: ${n.hex} !== ${e}`);return!0}function fr(t,e){if(!t.includes(e))throw new Error("item is not included in array")}function cr(t){for(const e of t){if(1!==t.filter((t=>t===e)).length)throw new Error("item in set is not unique: "+String(e))}}function ur(t){if(!t.every((e=>e===t[0])))throw new Error("set does not have equal items")}function ar(t,e){if(t.length!==e.length)throw new Error(`array lengths are unequal: ${t.length} !== ${e.length}`)}var hr=Object.freeze({__proto__:null,equal_arr_size:ar,exists:ir,is_equal_set:ur,is_included:fr,is_unique_set:cr,ok:or,size:sr});function dr(t,e){const n=t.find((t=>t.idx===e));if(void 0===n)throw new Error("record not found for index: "+e);return n}function lr(t){const e=xt.str(t).digest;return xt.join([e,e])}function gr(t,...e){const n=lr(t),r=e.map((t=>xt.bytes(t)));return xt.join([n,...r]).digest}var wr=Object.freeze({__proto__:null,assert:hr,count_scalars:function(t,e){return e.filter((e=>e===t)).length},get_record:dr,hash340:gr,random_bytes:function(t=32){return xt.random(t)},taghash:lr});const{POINT:pr,_0n:yr,_1n:br,_N:mr}=Zn;function Er(t,e){if(null===t&&null===e)throw new Error("both points are null!");if(null===t)return ir(e),e;if(null===e)return t;{const n=t.add(e);return n.assertValidity(),n}}function xr(t,e){const n=t.multiply(e);return n.assertValidity(),n}function vr(t){const e=En.ProjectivePoint.BASE.multiply(t);return e.assertValidity(),e}function _r(t){return xt.bytes(t.toRawBytes(!0))}function Br(t){const e=xt.bytes(t).hex;return pr.fromHex(e)}function Ar(t){return new xt(t,32)}var Ir=Object.freeze({__proto__:null,DeserializeElement:Br,DeserializeScalar:function(t){return xt.bytes(t).big},ElementAdd:Er,ElementAddMany:function(t){const e=t.slice(1).reduce(((t,e)=>Er(t,e)),t[0]);if(null===e)throw new Error("Summed point is null.");return e.assertValidity(),e},Identity:function(){return new pr(yr,br,yr)},Order:function(){return mr},RandomScalar:function(){return Wn(xt.random(32).big)},ScalarBaseMulti:vr,ScalarMulti:xr,SerializeElement:_r,SerializeScalar:Ar}),Sr=Object.freeze({__proto__:null,G:Ir,H:rr});function kr(t,e){const n=void 0!==e?xt.bytes(e,32):xt.random(32);return tr(xt.join([n,t]))}function Ur(t){return _r(vr(xt.bytes(t).big)).hex}function Or(t,e,n){const r=Nr(e,"bip340"),o=Nr(t,"bip340");sr(r,32),sr(o,32);return gr("BIP0340/challenge",o,r,n).big}function Nr(t,e){const n=xt.bytes(t);if("ecdsa"===e)return 32===n.length?n.prepend(2).hex:n.hex;if("bip340"===e)return 33===n.length?n.slice(1).hex:n.hex;throw new Error("invalid pubkey type")}function Rr(t){return t.map((t=>BigInt(t.idx)))}function Tr(t){let e=[];const n=t.sort(((t,e)=>t.idx-e.idx));for(const{idx:t,hidden_pn:r,binder_pn:o}of n){const n=[Ar(t),r,o];e=[...e,...n]}return xt.join(e)}function Lr(t,e,n){const r=er(xt.hex(n)),o=nr(Tr(t));return xt.join([e,r,o])}function zr(t,e){for(const n of t)if(e===n.idx)return xt.bytes(n.factor).big;throw new Error("invalid participant")}function qr(t,e){return t.map((({idx:t})=>{const n=Ar(t);return{idx:t,factor:Qn(xt.join([e,n])).hex}}))}function Hr(t,e){let n=null;for(const{idx:r,binder_pn:o,hidden_pn:i}of t){const t=Br(i),s=xr(Br(o),zr(e,r));n=Er(n,t),n=Er(n,s)}return ir(n),_r(n).hex}function $r(t,e){const n=xt.bytes(t).hex,r=Gn(n),o=function(t,e=[]){const n=e.map((t=>xt.bytes(t).big)),r=$n,o=jn-r;let i=t,s=r,f=r,c=Hn;for(const t of n){const e=vr(t);s=i.hasEvenY()?r:o,i=s===o?i.negate():i,i=Er(i,e),i.assertValidity(),f=Wn(s*f),c=Wn(t+s*c)}return s=i.hasEvenY()?r:o,{parity:s,point:i,state:f,tweak:c}}(r,e);return{int_pk:n,int_pt:r,group_pk:o.point.toHex(!0),group_pt:o}}function Pr(t,e,n){const r=t.group_pk,o=Lr(e,r,n).hex,i=qr(e,o),s=Hr(e,i),f=Rr(e);return{bind_prefix:o,bind_factors:i,challenge:Or(s,r,n),pnonces:e,group_pn:s,indexes:f,message:n=xt.bytes(n).hex}}function jr(t,e){if(e===Hn)throw new Error("x is zero");let n=Hn;for(const r of[...t].reverse())n*=e,n+=r,n=Wn(n);return n}function Cr(t){const e=t.map((t=>t[0]));let n=Hn;for(const[r,o]of t){n+=Vr(e,r)*o,n=Wn(n)}return n}function Vr(t,e){fr(t,e),cr(t);let n=$n,r=$n;for(const o of t)o!==e&&(n=Wn(Vn.mul(n,o)),r=Wn(Vn.mul(r,o-e)));return Wn(Vn.div(n,r))}function Fr(t,e,n){cr(t);let r=$n,o=$n;for(const i of t)i!==e&&(r=Wn(Vn.mul(r,n-i)),o=Wn(Vn.mul(o,e-i)));return Wn(Vn.div(r,o))}function Dr(t,e){const n=[];for(let r=0;r<e;r++){const e=t.at(r),o=void 0!==e?xt.bytes(e).big:xt.random(32).big;n.push(Wn(o))}return n}function Zr(t){return t.map((t=>vr(xt.bytes(t).big).toHex(!0)))}function Mr(t,e){const n=[];for(let r=1;r<e+1;r++){const e=jr(t,BigInt(r)),o=xt.big(e,32).hex;n.push({idx:r,seckey:o})}return n}function Kr(t){const e=t.map((t=>xt.bytes(t.seckey).big)).reduce(((t,e)=>Wn(t+=e)),Hn);return xt.big(e,32).hex}function Wr(t){ur(t.map((t=>t.idx)));return{idx:t[0].idx,seckey:Kr(t)}}function Yr(t,e,n=[]){const r=Dr(n,t);return{shares:Mr(r,e),vss_commits:Zr(r)}}var Gr=Object.freeze({__proto__:null,calc_lagrange_coeff:Fr,combine_partial_sigs:function(t,e){const{challenge:n,pnonces:r,group_pt:o,group_pk:i,message:s}=t,f=Hr(r,qr(r,Lr(r,i,s))),c=e.map((t=>xt.hex(t.psig).big)).reduce(((t,e)=>Wn(t+e)),Hn),u=Wn(n*o.parity*o.tweak),a=Wn(c+u);return xt.join([f.slice(2),xt.big(a,32)]).hex},combine_set:Wr,combine_shares:Kr,convert_pubkey:Nr,create_commit_pkg:function(t,e,n){const{idx:r,seckey:o}=t,i=kr(o,n).hex,s=kr(o,e).hex;return{idx:r,binder_pn:Ur(i),binder_sn:i,hidden_pn:Ur(s),hidden_sn:s}},create_dealer_set:function(t,e,n=[]){const r=Yr(t,e,n),o=r.vss_commits[0];return{...r,group_pk:o}},create_ecdh_share:function(t,e,n){const r=t.filter((t=>t!==e.idx)).map((t=>BigInt(t))),o=BigInt(e.idx),i=xt.hex(e.seckey).big,s=Gn(n),f=Wn(Fr(r,o,Hn)*i),c=_r(s.multiply(f)).hex;return{idx:e.idx,pubkey:c}},create_share_coeffs:Dr,create_share_set:Yr,create_shares:Mr,derive_ecdh_secret:function(t){let e=null;for(const n of t)if(null===e)e=Gn(n.pubkey);else{const t=Gn(n.pubkey);e=e.add(t)}return ir(e),_r(e).hex},derive_shares_secret:function(t){const e=Cr(t.map((t=>[BigInt(t.idx),xt.bytes(t.seckey).big])));return xt.big(e).hex},evaluate_x:jr,gen_recovery_shares:function(t,e,n,r,o=[]){or(t.length>=r,"not enough members to meet threshold"),t=t.sort();const i=BigInt(e.idx),s=BigInt(n),f=t.filter((t=>t!==e.idx)).map((t=>BigInt(t))),c=xt.hex(e.seckey).big,u=Fr(f,i,s);or(u>Hn,"lagrange coefficient must be greater than zero");const a=Dr(o,r-1),h=a.reduce(((t,e)=>Wn(t+e)),Hn),d=Wn(u*c-h),l=[...a,d],g=Zr(l),w=t.map(((t,e)=>({idx:t,seckey:xt.big(l[e]).hex})));return{idx:e.idx,vss_commits:g,shares:w}},gen_refresh_shares:function(t,e,n,r=[]){const o=Dr(r,e-1),i=Mr([Hn,...o],n);return{vss_commits:Zr(o),idx:t,shares:i}},generate_nonce:kr,generate_seckey:function(t){return tr(void 0!==t?xt.bytes(t,32):xt.random(32))},get_bind_factor:zr,get_challenge:Or,get_commit_pkg:function(t,e){return dr(t,e.idx)},get_commits_prefix:Tr,get_group_binders:qr,get_group_commit_context:Pr,get_group_key_context:$r,get_group_prefix:Lr,get_group_pubnonce:Hr,get_group_signing_ctx:function(t,e,n,r){const o=$r(t,r),i=Pr(o,e,n);return{...o,...i}},get_nonce_ids:Rr,get_pubkey:Ur,get_share:function(t,e){return dr(t,e)},get_share_commits:Zr,interpolate_root:Cr,interpolate_x:Vr,merge_share_commits:function(t,e){ar(t,e);const n=[];for(let r=0;r<t.length;r++){const o=_r(Er(Gn(t[r]),Gn(e[r])));n.push(o.hex)}return n},merge_shares:function(t,e){ar(t,e);const n=[];for(let r=0;r<t.length;r++){const o=t[r],i=Wr([o,dr(e,o.idx)]);n.push(i)}return n},recover_share:function(t,e){const n=t.map((t=>xt.hex(t.seckey).big)).reduce(((t,e)=>Wn(t+e)),Hn);return{idx:e,seckey:xt.big(n).hex}},refresh_share:function(t,e){return Wr([e,...t])},sign_msg:function(t,e,n){const{bind_factors:r,challenge:o,indexes:i,group_pt:s}=t,f=zr(r,e.idx),c=Vr(i,BigInt(e.idx));if(n.idx!==e.idx)throw new Error(`commit index does not match share index: ${n.idx} !== ${e.idx}`);let u=xt.bytes(n.hidden_sn).big,a=xt.bytes(n.binder_sn).big,h=xt.bytes(e.seckey).big;Gn(t.group_pn).hasEvenY()||(u=Cn.n-u,a=Cn.n-a);const d=Wn(s.parity*s.state*h),l=Wn(u+a*f),g=Wn(o*c*d+l);return{idx:e.idx,psig:xt.big(g,32).hex,pubkey:Ur(e.seckey)}},tweak_pubkey:function(t,e){const n=xt.bytes(e).big;let r=Gn(t);return r=r.multiply(n),_r(r).hex},tweak_seckey:function(t,e){const n=xt.bytes(e).big,r=Wn(xt.bytes(t).big*n);return xt.big(r).hex},verify_final_sig:function(t,e,n){const r=xt.bytes(n),o=xt.bytes(e);return qn.verify(r,o,t.group_pk.slice(2))},verify_partial_sig:function(t,e,n,r){const{bind_factors:o,challenge:i,indexes:s,group_pn:f,group_pt:c}=t,u=zr(o,e.idx);let a=Gn(e.hidden_pn),h=Gn(e.binder_pn),d=Gn(n);Gn(f).hasEvenY()||(a=xr(a,Cn.n-$n),h=xr(h,Cn.n-$n));const l=Er(a,xr(h,u)),g=Vr(s,BigInt(e.idx)),w=Wn(c.parity*c.state),p=Wn(i*g*w),y=vr(xt.hex(r).big),b=Er(l,xr(d,p));return y.x===b.x},verify_recovery_share:function(){},verify_share:function(t,e,n){const r=vr(xt.bytes(e.seckey).big);let o=null;for(let r=0;r<n;r++){o=Er(o,xr(Gn(t[r]),(i=e.idx,s=r,"number"==typeof i&&(i=BigInt(i)),"number"==typeof s&&(s=BigInt(s)),Ne(i,s,Kn))))}var i,s;return ir(o),r.x===o.x}});return t.CONST=Zn,t.ECC=Sr,t.Lib=Gr,t.Util=wr,t}({});
//# sourceMappingURL=script.js.map
