import { Buff } from '@cmdcode/buff';
import { mod_n } from '../ecc/util.js';
import { assert } from '../util/index.js';
import { _0n } from '../const.js';
import { calc_lagrange_coeff } from './poly.js';
import { create_share_coeffs, get_share_commits } from './vss.js';
export function gen_recovery_shares(members, share, target, threshold, secrets = []) {
    assert.ok(members.length >= threshold, 'not enough members to meet threshold');
    members = members.sort();
    const share_idx = BigInt(share.idx);
    const target_idx = BigInt(target);
    const mbrs = members
        .filter(idx => idx !== share.idx)
        .map(i => BigInt(i));
    const share_seckey = Buff.hex(share.seckey).big;
    const lgrng_coeff = calc_lagrange_coeff(mbrs, share_idx, target_idx);
    assert.ok(lgrng_coeff > _0n, 'lagrange coefficient must be greater than zero');
    const rand_coeffs = create_share_coeffs(secrets, threshold - 1);
    const coeff_sum = rand_coeffs.reduce((p, n) => mod_n(p + n), _0n);
    const repair_coeff = mod_n((lgrng_coeff * share_seckey) - coeff_sum);
    const repair_shares = [...rand_coeffs, repair_coeff];
    const vss_commits = get_share_commits(repair_shares);
    const shares = members.map((idx, i) => {
        return { idx, seckey: Buff.big(repair_shares[i]).hex };
    });
    return { idx: share.idx, vss_commits, shares };
}
export function recover_share(shares, idx) {
    const coeffs = shares.map(e => Buff.hex(e.seckey).big);
    const summed = coeffs.reduce((p, n) => mod_n(p + n), _0n);
    return { idx, seckey: Buff.big(summed).hex };
}
export function verify_recovery_share() {
}
