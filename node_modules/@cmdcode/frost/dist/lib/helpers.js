import { Buff } from '@cmdcode/buff';
import { G, H } from '../ecc/index.js';
import { lift_x, mod_n } from '../ecc/util.js';
import { assert, hash340 } from '../util/index.js';
export function generate_seckey(aux) {
    const aux_bytes = (aux !== undefined)
        ? Buff.bytes(aux, 32)
        : Buff.random(32);
    return H.H3(aux_bytes);
}
export function generate_nonce(secret, aux_seed) {
    const aux = (aux_seed !== undefined)
        ? Buff.bytes(aux_seed, 32)
        : Buff.random(32);
    const secret_seed = Buff.join([aux, secret]);
    return H.H3(secret_seed);
}
export function tweak_seckey(seckey, tweak) {
    const coeff = Buff.bytes(tweak).big;
    const secret = Buff.bytes(seckey).big;
    const tweaked = mod_n(secret * coeff);
    return Buff.big(tweaked).hex;
}
export function get_pubkey(secret) {
    const scalar = Buff.bytes(secret).big;
    const point = G.ScalarBaseMulti(scalar);
    return G.SerializeElement(point).hex;
}
export function tweak_pubkey(pubkey, tweak) {
    const coeff = Buff.bytes(tweak).big;
    let point = lift_x(pubkey);
    point = point.multiply(coeff);
    return G.SerializeElement(point).hex;
}
export function get_challenge(pnonce, pubkey, message) {
    const grp_pk = convert_pubkey(pubkey, 'bip340');
    const grp_pn = convert_pubkey(pnonce, 'bip340');
    assert.size(grp_pk, 32);
    assert.size(grp_pn, 32);
    const digest = hash340('BIP0340/challenge', grp_pn, grp_pk, message);
    return digest.big;
}
export function convert_pubkey(pubkey, type) {
    const pub = Buff.bytes(pubkey);
    if (type === 'ecdsa') {
        return pub.length === 32
            ? pub.prepend(2).hex
            : pub.hex;
    }
    else if (type === 'bip340') {
        return (pub.length === 33)
            ? pub.slice(1).hex
            : pub.hex;
    }
    else {
        throw new Error('invalid pubkey type');
    }
}
