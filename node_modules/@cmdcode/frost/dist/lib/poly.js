import { _0n, _1n, FIELD } from '../const.js';
import { mod_n } from '../ecc/util.js';
import { assert } from '../util/index.js';
export function evaluate_x(L, x) {
    if (x === _0n) {
        throw new Error('x is zero');
    }
    let value = _0n;
    for (const coeff of [...L].reverse()) {
        value *= x;
        value += coeff;
        value = mod_n(value);
    }
    return value;
}
export function interpolate_root(points) {
    const coeffs = points.map(e => e[0]);
    let p = _0n;
    for (const [x, y] of points) {
        const delta = interpolate_x(coeffs, x);
        p += delta * y;
        p = mod_n(p);
    }
    return p;
}
export function interpolate_x(L, x) {
    assert.is_included(L, x);
    assert.is_unique_set(L);
    let numerator = _1n, denominator = _1n;
    for (const x_j of L) {
        if (x_j === x)
            continue;
        numerator = mod_n(FIELD.mul(numerator, x_j));
        denominator = mod_n(FIELD.mul(denominator, x_j - x));
    }
    return mod_n(FIELD.div(numerator, denominator));
}
export function calc_lagrange_coeff(L, P, x) {
    assert.is_unique_set(L);
    let numerator = _1n, denominator = _1n;
    for (const x_j of L) {
        if (x_j === P)
            continue;
        numerator = mod_n(FIELD.mul(numerator, x - x_j));
        denominator = mod_n(FIELD.mul(denominator, P - x_j));
    }
    return mod_n(FIELD.div(numerator, denominator));
}
