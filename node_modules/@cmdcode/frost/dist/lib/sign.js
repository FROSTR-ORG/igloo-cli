import { Buff } from '@cmdcode/buff';
import { schnorr } from '@noble/curves/secp256k1';
import { G } from '../ecc/index.js';
import { lift_x, mod_n } from '../ecc/util.js';
import { _0n, _1n, CURVE } from '../const.js';
import { get_pubkey } from './helpers.js';
import { interpolate_x } from './poly.js';
import { get_group_binders, get_group_prefix, get_group_pubnonce, get_bind_factor } from './commit.js';
export function sign_msg(ctx, share, snonce) {
    const { bind_factors, challenge, indexes, group_pt: Q } = ctx;
    const bind_factor = get_bind_factor(bind_factors, share.idx);
    const coefficient = interpolate_x(indexes, BigInt(share.idx));
    if (snonce.idx !== share.idx) {
        throw new Error(`commit index does not match share index: ${snonce.idx} !== ${share.idx}`);
    }
    let snonce_h = Buff.bytes(snonce.hidden_sn).big, snonce_b = Buff.bytes(snonce.binder_sn).big, seckey = Buff.bytes(share.seckey).big;
    const R_elem = lift_x(ctx.group_pn);
    if (!R_elem.hasEvenY()) {
        snonce_h = CURVE.n - snonce_h;
        snonce_b = CURVE.n - snonce_b;
    }
    const sk = mod_n(Q.parity * Q.state * seckey);
    const nk = mod_n(snonce_h + (snonce_b * bind_factor));
    const ps = mod_n((challenge * coefficient * sk) + nk);
    return {
        idx: share.idx,
        psig: Buff.big(ps, 32).hex,
        pubkey: get_pubkey(share.seckey)
    };
}
export function combine_partial_sigs(context, psigs) {
    const { challenge, pnonces, group_pt: Q, group_pk, message } = context;
    const commit_prefix = get_group_prefix(pnonces, group_pk, message);
    const group_binders = get_group_binders(pnonces, commit_prefix);
    const group_pnonce = get_group_pubnonce(pnonces, group_binders);
    const ps = psigs
        .map(e => Buff.hex(e.psig).big)
        .reduce((acc, nxt) => mod_n(acc + nxt), _0n);
    const twk = mod_n(challenge * Q.parity * Q.tweak);
    const s = mod_n(ps + twk);
    return Buff.join([group_pnonce.slice(2), Buff.big(s, 32)]).hex;
}
export function verify_partial_sig(ctx, pnonce, share_pk, share_psig) {
    const { bind_factors, challenge, indexes, group_pn, group_pt: Q } = ctx;
    const binder = get_bind_factor(bind_factors, pnonce.idx);
    let hidden_elem = lift_x(pnonce.hidden_pn), binder_elem = lift_x(pnonce.binder_pn), public_elem = lift_x(share_pk);
    const R_elem = lift_x(group_pn);
    if (!R_elem.hasEvenY()) {
        hidden_elem = G.ScalarMulti(hidden_elem, CURVE.n - _1n);
        binder_elem = G.ScalarMulti(binder_elem, CURVE.n - _1n);
    }
    const commit_elem = G.ScalarMulti(binder_elem, binder);
    const nonce_elem = G.ElementAdd(hidden_elem, commit_elem);
    const lambda_i = interpolate_x(indexes, BigInt(pnonce.idx));
    const state = mod_n(Q.parity * Q.state);
    const chal = mod_n(challenge * lambda_i * state);
    const sig = Buff.hex(share_psig).big;
    const sG = G.ScalarBaseMulti(sig);
    const pki = G.ScalarMulti(public_elem, chal);
    const R = G.ElementAdd(nonce_elem, pki);
    return sG.x === R.x;
}
export function verify_final_sig(context, message, signature) {
    const sig = Buff.bytes(signature);
    const msg = Buff.bytes(message);
    return schnorr.verify(sig, msg, context.group_pk.slice(2));
}
