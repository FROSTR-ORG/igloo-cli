import { Buff } from '@cmdcode/buff';
import { G } from '../ecc/index.js';
import { _0n } from '../const.js';
import { assert, get_record } from '../util/index.js';
import { mod_n, pow_n, lift_x } from '../ecc/util.js';
import { interpolate_root, evaluate_x } from './poly.js';
export function create_shares(coeffs, count) {
    const shares = [];
    for (let i = 1; i < count + 1; i++) {
        const scalar = evaluate_x(coeffs, BigInt(i));
        const seckey = Buff.big(scalar, 32).hex;
        shares.push({ idx: i, seckey });
    }
    return shares;
}
export function get_share(shares, index) {
    return get_record(shares, index);
}
export function combine_shares(shares) {
    const secret = shares
        .map(e => Buff.bytes(e.seckey).big)
        .reduce((acc, cur) => mod_n(acc += cur), _0n);
    return Buff.big(secret, 32).hex;
}
export function combine_set(shares) {
    assert.is_equal_set(shares.map(e => e.idx));
    const idx = shares[0].idx;
    const seckey = combine_shares(shares);
    return { idx, seckey };
}
export function merge_shares(shares_a, shares_b) {
    assert.equal_arr_size(shares_a, shares_b);
    const shares = [];
    for (let i = 0; i < shares_a.length; i++) {
        const curr_share = shares_a[i];
        const aux_share = get_record(shares_b, curr_share.idx);
        const agg_share = combine_set([curr_share, aux_share]);
        shares.push(agg_share);
    }
    return shares;
}
export function verify_share(commits, share, thold) {
    const scalar = Buff.bytes(share.seckey).big;
    const S_i = G.ScalarBaseMulti(scalar);
    let S_ip = null;
    for (let j = 0; j < thold; j++) {
        const point = lift_x(commits[j]);
        const scalar = pow_n(share.idx, j);
        const prod = G.ScalarMulti(point, scalar);
        S_ip = G.ElementAdd(S_ip, prod);
    }
    assert.exists(S_ip);
    return S_i.x === S_ip.x;
}
export function derive_shares_secret(shares) {
    const coords = shares.map(share => [
        BigInt(share.idx),
        Buff.bytes(share.seckey).big
    ]);
    const secret = interpolate_root(coords);
    return Buff.big(secret).hex;
}
