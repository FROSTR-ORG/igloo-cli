import { Buff } from '@cmdcode/buff';
import { secp256k1, schnorr } from '@noble/curves/secp256k1';
import { gcm } from '@noble/ciphers/aes';
import { mod } from '@noble/curves/abstract/modular';
export function gen_seckey(secret) {
    let sbig = (secret !== undefined)
        ? Buff.hex(secret).big
        : Buff.random(32).big;
    sbig = mod(sbig, secp256k1.CURVE.n);
    return Buff.big(sbig).hex;
}
export function get_pubkey(seckey) {
    const pbytes = schnorr.getPublicKey(seckey);
    return new Buff(pbytes).hex;
}
export function get_shared_secret(seckey, peer_pk) {
    const pubkey = (peer_pk.length === 66)
        ? peer_pk
        : '02' + peer_pk;
    const sbytes = secp256k1.getSharedSecret(seckey, pubkey, true);
    return new Buff(sbytes).slice(1).hex;
}
export function sign_msg(seckey, message) {
    const sig = schnorr.sign(message, seckey);
    return new Buff(sig).hex;
}
export function verify_sig(message, pubkey, signature) {
    return schnorr.verify(signature, message, pubkey);
}
export function encrypt_content(secret, content, iv) {
    const cbytes = Buff.str(content);
    const sbytes = Buff.hex(secret);
    const vector = (iv !== undefined)
        ? Buff.hex(iv, 24)
        : Buff.random(24);
    const encrypted = gcm(sbytes, vector).encrypt(cbytes);
    return new Buff(encrypted).b64url + '?iv=' + vector.b64url;
}
export function decrypt_content(secret, content) {
    const [encryped, iv] = content.split('?iv=');
    const cbytes = Buff.b64url(encryped);
    const sbytes = Buff.hex(secret);
    const vector = Buff.b64url(iv);
    const decrypted = gcm(sbytes, vector).decrypt(cbytes);
    return new Buff(decrypted).str;
}
