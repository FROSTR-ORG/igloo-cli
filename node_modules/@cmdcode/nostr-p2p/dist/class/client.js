import EventEmitter from './emitter.js';
import { Buff } from '@cmdcode/buff';
import { SimplePool } from 'nostr-tools';
import { get_pubkey } from '../lib/crypto.js';
import { create_event } from '../lib/event.js';
import { gen_message_id } from '../lib/util.js';
import { finalize_message, create_payload, decrypt_payload, parse_envelope } from '../lib/message.js';
import { verify_relays, verify_seckey } from '../lib/validate.js';
import * as Util from '../util/index.js';
const NODE_CONFIG = () => {
    return {
        envelope: {
            kind: 20004,
            tags: []
        },
        filter: {
            kinds: [20004],
            since: Util.now()
        },
        req_timeout: 5000,
        since_offset: 5,
        start_delay: 2000
    };
};
export default class NostrNode extends EventEmitter {
    constructor(relays, seckey, options = {}) {
        super();
        this._inbox = {
            event: new EventEmitter(),
            id: new EventEmitter(),
            peer: new EventEmitter(),
            tag: new EventEmitter()
        };
        this._sub = null;
        this._handler = (event) => {
            try {
                const payload = decrypt_payload(event, this._seckey.hex);
                const msg = parse_envelope(payload, event);
                this.emit('message', msg);
                this.inbox.id.emit(msg.id, msg);
                this.inbox.peer.emit(msg.env.pubkey, msg);
                this.inbox.tag.emit(msg.tag, msg);
            }
            catch (err) {
                this.emit('bounced', [event.id, Util.parse_error(err)]);
            }
        };
        this._publish = async (message, peer_pk, options) => {
            const cache = options?.cache ?? new Map();
            const config = get_event_config(this, options);
            const payload = create_payload(message.tag, message.data, message.id);
            const event = create_event(config, payload, peer_pk, this._seckey.hex);
            const signed = { ...message, env: event };
            const receipts = this._pool.publish(this.relays, event);
            this._inbox.event.emit('published', signed);
            return Promise.all(receipts).then(acks => {
                const fails = this.relays.filter(r => !acks.includes(r));
                const msg_id = message.id;
                const ok = acks.length > 0;
                const res = { acks, fails, ok, peer_pk, data: signed };
                cache.set(peer_pk, res);
                this._inbox.event.emit('settled', { ...res, msg_id });
                return { ...res, ok, msg_id };
            });
        };
        verify_relays(relays);
        verify_seckey(seckey);
        this._seckey = new Buff(seckey);
        this._pubkey = get_pubkey(this._seckey.hex);
        this._config = get_node_config(options);
        this._filter = get_filter_config(this, options.filter);
        this._pool = new SimplePool();
        this._relays = relays;
        this.emit('info', ['filter:', JSON.stringify(this.filter, null, 2)]);
    }
    _subscribe(filter, timeout = this.config.req_timeout, sub_id = gen_message_id()) {
        this._filter = get_filter_config(this, filter);
        this.filter['#p'] = [...this.filter['#p'] ?? [], this.pubkey];
        this._sub = this._pool.subscribeMany(this.relays, [this._filter], {
            id: sub_id,
            oneose: () => this.emit('subscribed', [sub_id, this.filter]),
            onevent: this._handler
        });
        return new Promise(resolve => {
            const timer = setTimeout(() => resolve('timeout'), timeout);
            const resolver = (reason) => { clearTimeout(timer); resolve(reason); };
            this.within('subscribed', ([id]) => {
                if (id === sub_id)
                    resolver(null);
            }, timeout);
        });
    }
    get config() {
        return this._config;
    }
    get filter() {
        return this._filter;
    }
    get inbox() {
        return this._inbox;
    }
    get pubkey() {
        return this._pubkey;
    }
    get relays() {
        return this._relays;
    }
    async broadcast(message, peers, options) {
        const cache = new Map();
        const msg = finalize_message(message);
        const outbox = peers.map(pk => this._publish(msg, pk, options));
        return Promise.all(outbox).then(settled => {
            const ok = settled.every(r => r.ok);
            const res = { ok, cache, msg_id: msg.id, peers };
            settled.forEach(r => cache.set(r.peer_pk, r));
            this.emit('broadcast', res);
            return { ...res };
        });
    }
    async connect(timeout = this.config.req_timeout) {
        const res = await this._subscribe(this._filter, timeout);
        if (res !== null)
            throw new Error(res);
        this.emit('ready', this);
        return this;
    }
    async close() {
        if (this._sub !== null) {
            this._sub.close();
        }
        if (this._pool.close !== undefined) {
            this._pool.close(this.relays);
        }
        this.emit('close', this);
    }
    async request(message, peer_pk, options) {
        const msg = finalize_message(message);
        const receipt = this.subscribe({ id: msg.id, peers: [peer_pk] }, options);
        this.publish(msg, peer_pk, options);
        return receipt;
    }
    async multicast(message, peers, options = {}) {
        const msg = finalize_message(message);
        const sub = this.subscribe({ id: msg.id, peers }, options);
        const pub = this.broadcast(msg, peers, options);
        return Promise.all([sub, pub]).then(([sub, pub]) => {
            return { sub, pub };
        });
    }
    async publish(message, pubkey, options) {
        const msg = finalize_message(message);
        return this._publish(msg, pubkey, options);
    }
    async subscribe(filter, options) {
        const config = get_sub_config(this, options);
        return new Promise(resolve => {
            const { timeout, threshold } = config;
            const { id, peers = [], tag } = filter;
            const authors = new Set();
            const inbox = new Set();
            const timer = setTimeout(() => resolver(false, 'timeout'), timeout);
            const resolver = (ok, reason) => {
                clearTimeout(timer);
                const res = {
                    ok,
                    authors: Array.from(authors),
                    inbox: Array.from(inbox),
                    peers,
                    reason
                };
                this.emit('resolved', res);
                resolve({ ...res });
            };
            const is_bounce = (msg) => ((typeof id === 'string' && id !== msg.id) ||
                (typeof tag === 'string' && tag !== msg.tag) ||
                (peers.length > 0 && !peers.includes(msg.env.pubkey)));
            this.within('message', (msg) => {
                if (!is_bounce(msg)) {
                    authors.add(msg.env.pubkey);
                    inbox.add(msg);
                }
                if (typeof threshold === 'number' && authors.size >= threshold) {
                    resolver(true, 'threshold');
                }
                if (Array.isArray(peers) && peers.every(e => authors.has(e))) {
                    resolver(true, 'complete');
                }
            }, timeout);
        });
    }
    async update(filter) {
        if (this._sub !== null)
            this._sub.close();
        return this._subscribe(filter);
    }
}
function get_node_config(opt = {}) {
    const config = NODE_CONFIG();
    const envelope = { ...config.envelope, ...opt.envelope };
    const filter = { ...config.filter, ...opt.filter };
    return { ...config, envelope, filter };
}
function get_event_config(node, opt = {}) {
    let { created_at = Util.now(), tags = [], ...rest } = opt;
    const envelope = node.config.envelope;
    tags = [...envelope.tags ?? [], ...opt.tags ?? []];
    return { ...envelope, ...rest, created_at, tags };
}
function get_filter_config(node, filter = {}) {
    return { ...node.config.filter, ...filter };
}
function get_sub_config(node, opt = {}) {
    const timeout = opt.timeout ?? node.config.req_timeout;
    return { ...opt, timeout };
}
