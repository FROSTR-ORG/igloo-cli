import { Buff } from '@cmdcode/buff';
import { Assert } from './assert.js';
import { secp256k1, schnorr } from '@noble/curves/secp256k1';
import { Field } from '@noble/curves/abstract/modular';
const _N = secp256k1.CURVE.n;
const FD = Field(_N, 32, true);
const GP = secp256k1.ProjectivePoint.BASE;
export function get_seckey(secret, even_y = false) {
    let sk = serialize_bytes(secret).big % _N;
    if (even_y) {
        const pt = GP.multiply(sk);
        return (pt.hasEvenY())
            ? Buff.big(sk).hex
            : Buff.big(_N - sk).hex;
    }
    else {
        return Buff.big(sk).hex;
    }
}
export function get_pubkey(seckey, format) {
    const sk = serialize_bytes(seckey).big;
    const pt = GP.multiply(sk);
    const pk = pt.toHex(true);
    return convert_pubkey(pk, format);
}
export function tweak_seckey(seckey, tweak, even_y = false) {
    const sk = serialize_bytes(seckey).big;
    const twk = serialize_bytes(tweak).big;
    const tweaked_sk = FD.add(sk, twk);
    const new_secret = Buff.big(tweaked_sk);
    return get_seckey(new_secret, even_y);
}
export function tweak_pubkey(pubkey, tweak, even_y = false) {
    const format = get_pubkey_format(pubkey);
    const twk_big = serialize_bytes(tweak).big;
    const pub_pt = lift_pubkey(pubkey);
    const tweak_pt = GP.multiply(twk_big);
    let tweaked_pt = pub_pt.add(tweak_pt);
    if (even_y && !tweaked_pt.hasEvenY()) {
        tweaked_pt = tweaked_pt.negate();
    }
    const pk = tweaked_pt.toHex(true);
    return convert_pubkey(pk, format);
}
export function verify_seckey(seckey) {
    const sk = serialize_bytes(seckey);
    Assert.size(sk, 32, 'ecdsa secret keys must be 32 bytes long');
    Assert.ok(sk.big < _N, 'ecdsa secret keys must be less than the curve order');
    Assert.ok(sk.big > 0, 'ecdsa secret keys must be greater than zero');
}
export function verify_pubkey(pubkey, format) {
    const pk = serialize_bytes(pubkey);
    if (format === 'bip340') {
        Assert.size(pk, 32, 'bip340 public keys must be 32 bytes long');
    }
    else if (format === 'ecdsa') {
        Assert.size(pk, 33, 'ecdsa public keys must be 33 bytes long');
    }
    else {
        throw new Error('invalid format: ' + format);
    }
    verify_point(pk);
}
export function verify_signature(signature, message, pubkey, format) {
    const sig = serialize_bytes(signature);
    const msg = serialize_bytes(message);
    const pk = serialize_pubkey(pubkey, format);
    return (format === 'bip340')
        ? schnorr.verify(sig, msg, pk)
        : secp256k1.verify(sig, msg, pk);
}
export function verify_point(pubkey) {
    try {
        const pt = lift_pubkey(pubkey);
        pt.assertValidity();
    }
    catch (err) {
        throw new Error('invalid secp256k1 point: ' + pubkey);
    }
}
export function verify_even_y(pubkey) {
    const pt = lift_pubkey(pubkey);
    Assert.ok(pt.hasEvenY(), 'pubkey must have an even y-coordinate');
}
export function lift_pubkey(pubkey) {
    try {
        const pk = convert_pubkey(pubkey, 'ecdsa');
        return secp256k1.ProjectivePoint.fromHex(pk);
    }
    catch (err) {
        throw new Error('invalid pubkey: ' + pubkey);
    }
}
export function serialize_pubkey(pubkey, format) {
    try {
        const pk = serialize_bytes(pubkey);
        if (pk.length === 33 && format === 'bip340') {
            return pk.slice(1);
        }
        else if (pk.length === 32 && format === 'ecdsa') {
            return pk.prepend(0x02);
        }
        else {
            return pk;
        }
    }
    catch (err) {
        throw new Error('invalid pubkey: ' + String(pubkey));
    }
}
export function convert_pubkey(pubkey, format) {
    const pk = serialize_pubkey(pubkey, format);
    return pk.hex;
}
export function get_pubkey_format(pubkey) {
    const pk = serialize_bytes(pubkey);
    if (pk.length === 33)
        return 'ecdsa';
    if (pk.length === 32)
        return 'bip340';
    throw new Error('invalid pubkey: ' + String(pubkey));
}
export function serialize_bytes(bytes) {
    try {
        return Buff.bytes(bytes);
    }
    catch (err) {
        throw new Error('invalid bytes: ' + String(bytes));
    }
}
