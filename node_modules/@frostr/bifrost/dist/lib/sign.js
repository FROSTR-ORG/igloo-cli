import { get_pubkey } from '../util/crypto.js';
import { create_member_shares } from './session.js';
import { Assert } from '../util/assert.js';
import { combine_partial_sigs, sign_msg, verify_partial_sig } from '@cmdcode/frost/lib';
export function create_psig_pkg(ctx, share) {
    const sid = ctx.session.sid;
    const pubkey = get_pubkey(share.seckey, 'ecdsa');
    const sighashes = ctx.session.hashes.map(e => e[0]);
    const sig_shares = create_member_shares(ctx.session, share);
    const psigs = sighashes.map(sighash => {
        const sig_share = sig_shares.find(e => e.sighash === sighash);
        const sig_ctx = ctx.sigmap.get(sighash);
        Assert.exists(sig_share, 'share not found for sighash: ' + sighash);
        Assert.exists(sig_ctx, 'context not found for sighash: ' + sighash);
        const psig = create_partial_sig(sig_ctx, sig_share);
        return [sighash, psig];
    });
    return { idx: share.idx, psigs, pubkey, sid };
}
export function verify_psig_pkg(ctx, pkg) {
    const { idx, psigs, pubkey, sid } = pkg;
    if (sid !== ctx.session.sid)
        return 'session id mismatch';
    if (!ctx.pubkeys.includes(pubkey))
        return 'pubkey not found in group';
    for (const [sighash, sigctx] of ctx.sigmap.entries()) {
        const psig_entry = psigs.find(e => e[0] === sighash);
        if (psig_entry === undefined)
            return 'partial signature entry not found for sighash: ' + sighash;
        const pnonce = sigctx.pnonces.find(e => e.idx === idx);
        if (pnonce === undefined)
            return 'commit package not found for psig idx: ' + idx;
        if (!verify_partial_sig(sigctx, pnonce, pubkey, psig_entry[1]))
            return 'partial signature invalid';
    }
    return null;
}
export function create_psig_records(pkgs) {
    return pkgs.map(({ idx, psigs, pubkey, sid }) => {
        return psigs.map(([sighash, psig]) => ({ sighash, idx, pubkey, psig, sid }));
    }).flat();
}
export function combine_signature_pkgs(ctx, pkgs) {
    const count = ctx.session.members.length;
    const records = create_psig_records(pkgs);
    const sigs = [];
    for (const [sighash, sigctx] of ctx.sigmap.entries()) {
        const psigs = records.filter(e => e.sighash === sighash);
        Assert.ok(psigs.length === count, 'missing partial signatures for sighash: ' + sighash);
        const pubkey = sigctx.group_pk;
        const sig = combine_partial_sigs(sigctx, psigs);
        sigs.push([sighash, pubkey, sig]);
    }
    return sigs;
}
export function create_partial_sig(ctx, share) {
    const { idx, binder_sn, hidden_sn, seckey } = share;
    const secshare = { idx, seckey };
    const secnonce = { idx, binder_sn, hidden_sn };
    const psig_pkg = sign_msg(ctx, secshare, secnonce);
    return psig_pkg.psig;
}
