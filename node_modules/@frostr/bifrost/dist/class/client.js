import { EventEmitter } from './emitter.js';
import { BifrostSigner } from './signer.js';
import { SignerQueue } from './queue.js';
import { NostrNode } from '@cmdcode/nostr-p2p';
import { parse_error } from '@cmdcode/nostr-p2p/util';
import { convert_pubkey } from '../util/crypto.js';
import { now } from '../util/helpers.js';
import { parse_ecdh_message, parse_session_message } from '../lib/parse.js';
import { get_peer_pubkeys, get_recv_pubkeys } from '../lib/peer.js';
import * as API from '../api/index.js';
import Schema from '../schema/index.js';
const DEFAULT_CACHE = () => {
    return {
        ecdh: new Map()
    };
};
const DEFAULT_CONFIG = () => {
    return {
        debug: false,
        middleware: {},
        policies: [],
        sign_ival: 100
    };
};
export class BifrostNode extends EventEmitter {
    constructor(group, share, relays, options) {
        super();
        this._is_ready = false;
        this._cache = get_node_cache(options?.cache);
        this._config = get_node_config(options);
        this._queue = new SignerQueue(this);
        this._signer = new BifrostSigner(group, share, options);
        this._peers = init_peer_data(this);
        const authors = [...get_peer_pubkeys(this.peers), this.pubkey];
        this._client = new NostrNode(relays, share.seckey, { filter: { authors } });
        this._client.on('closed', () => {
            this._is_ready = false;
            this.emit('closed', this);
        });
        this._client.on('ready', () => {
            this._is_ready = true;
            this.emit('ready', this);
        });
        this._client.on('message', (msg) => {
            this.emit('message', msg);
            if (!this._filter(msg))
                return;
            try {
                switch (msg.tag) {
                    case '/ping/req': {
                        API.ping_handler_api(this, msg);
                        break;
                    }
                    case '/ecdh/req': {
                        const parsed = parse_ecdh_message(msg);
                        API.ecdh_handler_api(this, parsed);
                        break;
                    }
                    case '/sign/req': {
                        const parsed = parse_session_message(msg);
                        API.sign_handler_api(this, parsed);
                        break;
                    }
                }
            }
            catch (err) {
                this.emit('bounced', [parse_error(err), msg]);
            }
        });
    }
    _filter(msg) {
        const { pubkey } = msg.env;
        if (msg.tag === '/echo/req')
            return true;
        if (pubkey === this.pubkey)
            return false;
        if (msg.tag === '/ping/req')
            return true;
        const recv_pks = get_recv_pubkeys(this.peers);
        if (!recv_pks.includes(msg.env.pubkey)) {
            this.emit('bounced', ['unauthorized', msg]);
            return false;
        }
        else {
            return true;
        }
    }
    get cache() {
        return this._cache;
    }
    get client() {
        return this._client;
    }
    get config() {
        return this._config;
    }
    get debug() {
        return this._config.debug;
    }
    get group() {
        return this._signer.group;
    }
    get is_ready() {
        return this._is_ready;
    }
    get queue() {
        return this._queue;
    }
    get peers() {
        return this._peers;
    }
    get pubkey() {
        return convert_pubkey(this.signer.pubkey, 'bip340');
    }
    get req() {
        return {
            ecdh: API.ecdh_request_api(this),
            echo: API.echo_request_api(this),
            ping: API.ping_request_api(this),
            queue: API.sign_queue_api(this),
            sign: API.sign_request_api(this)
        };
    }
    get signer() {
        return this._signer;
    }
    async connect() {
        void this.client.connect();
    }
    async close() {
        void this.client.close();
    }
    update_peer(data) {
        const idx = this.peers.findIndex(e => e.pubkey === data.pubkey);
        if (idx === -1)
            return;
        this._peers[idx] = { ...this._peers[idx], ...data };
    }
}
function get_node_cache(opt = {}) {
    return { ...DEFAULT_CACHE(), ...opt };
}
function get_node_config(opt = {}) {
    const config = { ...DEFAULT_CONFIG(), ...opt };
    const parsed = Schema.node.config.safeParse(config);
    if (!parsed.success)
        throw new Error('invalid node config');
    return parsed.data;
}
function init_peer_data(node) {
    const current = now();
    const node_pk = node.pubkey;
    const peers_pks = node.group.commits
        .map(e => convert_pubkey(e.pubkey, 'bip340'))
        .filter(e => e !== node_pk);
    let peer_data = [];
    for (const peer_pk of peers_pks) {
        const config = node.config.policies.find(e => e.pubkey === peer_pk);
        const policy = config?.policy ?? { send: true, recv: true };
        peer_data.push({
            policy: policy,
            pubkey: peer_pk,
            status: 'offline',
            updated: current
        });
    }
    return peer_data;
}
