export class EventEmitter {
    constructor() {
        this.eventMap = new Map();
    }
    _get_event_handlers(eventName) {
        const handlers = this.eventMap.get(eventName);
        if (!handlers) {
            const newHandlers = new Set();
            this.eventMap.set(eventName, newHandlers);
            return newHandlers;
        }
        return handlers;
    }
    has(eventName) {
        const handlers = this.eventMap.get(eventName);
        return handlers !== undefined && handlers.size > 0;
    }
    on(eventName, handler) {
        this._get_event_handlers(eventName).add(handler);
    }
    once(eventName, handler) {
        const once_handler = ((payload) => {
            this.off(eventName, once_handler);
            void invoke_handler(handler, payload);
        });
        this.on(eventName, once_handler);
    }
    within(eventName, handler, timeoutMs) {
        const timeout_handler = ((payload) => {
            void invoke_handler(handler, payload);
        });
        setTimeout(() => {
            this.off(eventName, timeout_handler);
        }, timeoutMs);
        this.on(eventName, timeout_handler);
    }
    emit(eventName, payload) {
        const promises = [];
        this._get_event_handlers(eventName).forEach(handler => {
            const result = invoke_handler(handler, payload);
            if (result instanceof Promise) {
                promises.push(result);
            }
        });
        this._get_event_handlers('*').forEach(handler => {
            const result = invoke_handler(handler, [eventName, payload]);
            if (result instanceof Promise) {
                promises.push(result);
            }
        });
        void Promise.allSettled(promises);
    }
    off(eventName, handler) {
        this._get_event_handlers(eventName).delete(handler);
    }
    clear(eventName) {
        this.eventMap.delete(eventName);
    }
}
function invoke_handler(handler, payload) {
    if (Array.isArray(payload) && payload.length > 0) {
        return handler.apply(null, payload);
    }
    return handler(payload);
}
