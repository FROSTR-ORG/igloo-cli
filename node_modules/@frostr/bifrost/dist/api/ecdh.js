import { finalize_message } from '@cmdcode/nostr-p2p/lib';
import { combine_ecdh_pkgs } from '../lib/ecdh.js';
import { parse_ecdh_message } from '../lib/parse.js';
import { Assert, copy_obj, parse_error } from '../util/index.js';
import { get_member_indexes, select_random_peers } from '../lib/util.js';
import { get_send_pubkeys } from '../lib/peer.js';
export async function ecdh_handler_api(node, msg) {
    const middleware = node.config.middleware.ecdh;
    try {
        node.emit('/ecdh/handler/req', copy_obj(msg));
        if (typeof middleware === 'function') {
            msg = middleware(node, msg);
        }
        const { members, ecdh_pk } = msg.data;
        const pkg = node.signer.gen_ecdh_share(members, ecdh_pk);
        const envelope = finalize_message({
            data: JSON.stringify(pkg),
            id: msg.id,
            tag: '/ecdh/res'
        });
        const res = await node.client.publish(envelope, msg.env.pubkey);
        if (!res.ok)
            throw new Error('failed to publish response');
        node.emit('/ecdh/handler/res', copy_obj(res.data));
    }
    catch (err) {
        if (node.debug)
            console.log(err);
        node.emit('/ecdh/handler/rej', [parse_error(err), copy_obj(msg)]);
    }
}
export function ecdh_request_api(node) {
    return async (ecdh_pk, peers) => {
        const thold = node.group.threshold;
        const send_pks = get_send_pubkeys(node.peers);
        const selected = select_random_peers(peers ??= send_pks, thold);
        const encrypted = node.cache.ecdh.get(ecdh_pk);
        if (encrypted !== undefined) {
            return { ok: true, data: node.signer.unwrap(encrypted, ecdh_pk) };
        }
        const members = get_member_indexes(node.group, [node.pubkey, ...selected]);
        const self_pkg = node.signer.gen_ecdh_share(members, ecdh_pk);
        let msgs = null;
        try {
            msgs = await create_ecdh_request(node, selected, self_pkg);
            node.emit('/ecdh/sender/res', copy_obj(msgs));
        }
        catch (err) {
            if (node.debug)
                console.log(err);
            const reason = parse_error(err);
            node.emit('/ecdh/sender/rej', [reason, copy_obj(self_pkg)]);
            return { ok: false, err: reason };
        }
        try {
            Assert.ok(msgs !== null, 'no responses from peers');
            const pkgs = [self_pkg, ...msgs.map(e => e.data)];
            const secret = finalize_ecdh_response(pkgs);
            const content = node.signer.wrap(secret, ecdh_pk);
            node.cache.ecdh.set(ecdh_pk, content);
            node.emit('/ecdh/sender/ret', [ecdh_pk, secret]);
            return { ok: true, data: secret };
        }
        catch (err) {
            if (node.debug)
                console.log(err);
            const reason = parse_error(err);
            node.emit('/ecdh/sender/err', [reason, copy_obj(msgs ?? [])]);
            return { ok: false, err: reason };
        }
    };
}
async function create_ecdh_request(node, peers, pkg) {
    const msg = { data: JSON.stringify(pkg), tag: '/ecdh/req' };
    const res = await node.client.multicast(msg, peers);
    if (!res.sub.ok)
        throw new Error(res.sub.reason);
    return res.sub.inbox.map(e => {
        const parsed = parse_ecdh_message(e);
        Assert.ok(parsed !== null, 'invalid ecdh response from pubkey: ' + e.env.pubkey);
        return parsed;
    });
}
function finalize_ecdh_response(pkgs) {
    return combine_ecdh_pkgs(pkgs);
}
