import { finalize_message } from '@cmdcode/nostr-p2p/lib';
import Schema from '../schema/index.js';
import { Assert, now, parse_error } from '../util/index.js';
export async function ping_handler_api(node, msg) {
    try {
        node.emit('/ping/handler/req', msg);
        const peer_data = node.peers.find(e => e.pubkey === msg.env.pubkey);
        if (peer_data === undefined)
            throw new Error('peer data not found');
        const envelope = finalize_message({
            data: JSON.stringify(peer_data.policy),
            id: msg.id,
            tag: '/ping/res'
        });
        const res = await node.client.publish(envelope, msg.env.pubkey);
        if (!res.ok)
            throw new Error('failed to publish response');
        node.update_peer({
            ...peer_data,
            status: 'online',
            updated: now()
        });
        node.emit('/ping/handler/res', res.data);
    }
    catch (err) {
        if (node.debug)
            console.log(err);
        node.emit('/ping/handler/rej', [parse_error(err), msg]);
    }
}
export function ping_request_api(node) {
    return async (pubkey) => {
        const peer_data = node.peers.find(e => e.pubkey === pubkey);
        Assert.exists(peer_data, 'peer data not found');
        let msg = null;
        try {
            msg = await create_ping_request(node, pubkey);
            node.emit('/ping/sender/res', msg);
        }
        catch (err) {
            if (node.debug)
                console.log(err);
            const reason = parse_error(err);
            node.emit('/ping/sender/rej', [reason, msg]);
            return { ok: false, err: reason };
        }
        try {
            Assert.ok(msg !== null, 'no response from peer');
            const policy = parse_ping_response(msg);
            if (policy === null)
                throw new Error('invalid ping response');
            const new_data = {
                ...peer_data,
                status: 'online',
                updated: now()
            };
            node.update_peer(new_data);
            node.emit('/ping/sender/ret', new_data);
            return { ok: true, data: policy };
        }
        catch (err) {
            if (node.debug)
                console.log(err);
            const reason = parse_error(err);
            node.emit('/ping/sender/err', [reason, msg]);
            node.update_peer({
                ...peer_data,
                status: 'offline',
                updated: now()
            });
            return { ok: false, err: reason };
        }
    };
}
async function create_ping_request(node, pubkey) {
    const res = await node.client.request({
        data: 'ping',
        tag: '/ping/req'
    }, pubkey, {});
    if (!res.ok)
        throw new Error(res.reason);
    return res.inbox[0];
}
function parse_ping_response(msg) {
    try {
        const json = JSON.parse(msg.data);
        const parsed = Schema.peer.policy.safeParse(json);
        if (!parsed.success)
            return null;
        return parsed.data;
    }
    catch {
        return null;
    }
}
