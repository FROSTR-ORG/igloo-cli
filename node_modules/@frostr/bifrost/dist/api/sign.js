import { finalize_message } from '@cmdcode/nostr-p2p/lib';
import { parse_psig_message } from '../lib/parse.js';
import { get_send_pubkeys } from '../lib/peer.js';
import { format_sigvector } from '../lib/sighash.js';
import { get_member_indexes, select_random_peers } from '../lib/util.js';
import { Assert, copy_obj, parse_error } from '../util/index.js';
import { create_session_pkg, create_session_template, get_session_ctx } from '../lib/session.js';
import { combine_signature_pkgs, verify_psig_pkg } from '../lib/sign.js';
export async function sign_handler_api(node, msg) {
    const middleware = node.config.middleware.sign;
    try {
        node.emit('/sign/handler/req', copy_obj(msg));
        if (typeof middleware === 'function') {
            msg = middleware(node, msg);
        }
        const pkg = node.signer.sign_session(msg.data);
        const envelope = finalize_message({
            data: JSON.stringify(pkg),
            id: msg.id,
            tag: '/sign/res'
        });
        const res = await node.client.publish(envelope, msg.env.pubkey);
        if (!res.ok)
            throw new Error('failed to publish response');
        node.emit('/sign/handler/res', copy_obj(res.data));
    }
    catch (err) {
        if (node.debug)
            console.log(err);
        node.emit('/sign/handler/rej', [parse_error(err), copy_obj(msg)]);
    }
}
export function sign_queue_api(node) {
    return async (message) => {
        const sigvec = format_sigvector(message);
        return node.queue.push(sigvec);
    };
}
export function sign_request_api(node) {
    return async (message, options = {}) => {
        const sigvecs = typeof message === 'string' ? [[message]] : message;
        const send_pks = get_send_pubkeys(node.peers);
        const peers = options.peers ??= send_pks;
        const thold = node.group.threshold;
        const selected = select_random_peers(peers, thold);
        const members = get_member_indexes(node.group, [node.pubkey, ...selected]);
        const template = create_session_template(members, sigvecs, options);
        Assert.ok(template !== null, 'invalid session template');
        const session = create_session_pkg(node.group, template);
        let msgs = null;
        try {
            msgs = await create_sign_request(node, selected, session);
            node.emit('/sign/sender/res', copy_obj(msgs));
        }
        catch (err) {
            if (node.debug)
                console.log(err);
            const reason = parse_error(err);
            node.emit('/sign/sender/rej', [reason, session]);
            return { ok: false, err: reason };
        }
        try {
            Assert.ok(msgs !== null, 'no responses from peers');
            const sigs = finalize_sign_response(node, msgs, session);
            node.emit('/sign/sender/ret', [session.sid, sigs]);
            return { ok: true, data: sigs };
        }
        catch (err) {
            if (node.debug)
                console.log(err);
            const reason = parse_error(err);
            node.emit('/sign/sender/err', [reason, msgs ?? []]);
            return { ok: false, err: reason };
        }
    };
}
async function create_sign_request(node, peers, session) {
    const res = await node.client.multicast({
        data: JSON.stringify(session),
        tag: '/sign/req'
    }, peers);
    if (!res.sub.ok)
        throw new Error(res.sub.reason);
    return res.sub.inbox;
}
function finalize_sign_response(node, responses, session) {
    const ctx = get_session_ctx(node.group, session);
    const pkgs = [node.signer.sign_session(session)];
    responses.forEach(e => {
        const parsed = parse_psig_message(e);
        const error = verify_psig_pkg(ctx, parsed.data);
        Assert.ok(error === null, error + ' : ' + e.env.pubkey);
        pkgs.push(parsed.data);
    });
    return combine_signature_pkgs(ctx, pkgs);
}
