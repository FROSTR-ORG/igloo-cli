import { z } from 'zod';
import type { BifrostNode, SignatureEntry, ECDHPackage, SignSessionPackage } from '@frostr/bifrost';
export declare const KeysetParamsSchema: z.ZodEffects<z.ZodObject<{
    threshold: z.ZodNumber;
    totalMembers: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    threshold: number;
    totalMembers: number;
}, {
    threshold: number;
    totalMembers: number;
}>, {
    threshold: number;
    totalMembers: number;
}, {
    threshold: number;
    totalMembers: number;
}>;
export declare const RelayUrlSchema: z.ZodString;
export declare const SecretKeySchema: z.ZodString;
export declare const NodePolicyInputSchema: z.ZodObject<{
    pubkey: z.ZodEffects<z.ZodString, string, string>;
    allowSend: z.ZodOptional<z.ZodBoolean>;
    allowReceive: z.ZodOptional<z.ZodBoolean>;
    send: z.ZodOptional<z.ZodBoolean>;
    recv: z.ZodOptional<z.ZodBoolean>;
    policy: z.ZodOptional<z.ZodObject<{
        send: z.ZodOptional<z.ZodBoolean>;
        recv: z.ZodOptional<z.ZodBoolean>;
    }, "strip", z.ZodTypeAny, {
        send?: boolean | undefined;
        recv?: boolean | undefined;
    }, {
        send?: boolean | undefined;
        recv?: boolean | undefined;
    }>>;
    label: z.ZodOptional<z.ZodString>;
    roles: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
    metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
    note: z.ZodOptional<z.ZodString>;
    source: z.ZodOptional<z.ZodEnum<["config", "runtime"]>>;
}, "strip", z.ZodTypeAny, {
    pubkey: string;
    allowSend?: boolean | undefined;
    allowReceive?: boolean | undefined;
    send?: boolean | undefined;
    recv?: boolean | undefined;
    policy?: {
        send?: boolean | undefined;
        recv?: boolean | undefined;
    } | undefined;
    label?: string | undefined;
    roles?: string[] | undefined;
    metadata?: Record<string, any> | undefined;
    note?: string | undefined;
    source?: "config" | "runtime" | undefined;
}, {
    pubkey: string;
    allowSend?: boolean | undefined;
    allowReceive?: boolean | undefined;
    send?: boolean | undefined;
    recv?: boolean | undefined;
    policy?: {
        send?: boolean | undefined;
        recv?: boolean | undefined;
    } | undefined;
    label?: string | undefined;
    roles?: string[] | undefined;
    metadata?: Record<string, any> | undefined;
    note?: string | undefined;
    source?: "config" | "runtime" | undefined;
}>;
export declare const NodeConfigSchema: z.ZodObject<{
    group: z.ZodString;
    share: z.ZodString;
    relays: z.ZodArray<z.ZodString, "many">;
    policies: z.ZodOptional<z.ZodArray<z.ZodObject<{
        pubkey: z.ZodEffects<z.ZodString, string, string>;
        allowSend: z.ZodOptional<z.ZodBoolean>;
        allowReceive: z.ZodOptional<z.ZodBoolean>;
        send: z.ZodOptional<z.ZodBoolean>;
        recv: z.ZodOptional<z.ZodBoolean>;
        policy: z.ZodOptional<z.ZodObject<{
            send: z.ZodOptional<z.ZodBoolean>;
            recv: z.ZodOptional<z.ZodBoolean>;
        }, "strip", z.ZodTypeAny, {
            send?: boolean | undefined;
            recv?: boolean | undefined;
        }, {
            send?: boolean | undefined;
            recv?: boolean | undefined;
        }>>;
        label: z.ZodOptional<z.ZodString>;
        roles: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
        metadata: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;
        note: z.ZodOptional<z.ZodString>;
        source: z.ZodOptional<z.ZodEnum<["config", "runtime"]>>;
    }, "strip", z.ZodTypeAny, {
        pubkey: string;
        allowSend?: boolean | undefined;
        allowReceive?: boolean | undefined;
        send?: boolean | undefined;
        recv?: boolean | undefined;
        policy?: {
            send?: boolean | undefined;
            recv?: boolean | undefined;
        } | undefined;
        label?: string | undefined;
        roles?: string[] | undefined;
        metadata?: Record<string, any> | undefined;
        note?: string | undefined;
        source?: "config" | "runtime" | undefined;
    }, {
        pubkey: string;
        allowSend?: boolean | undefined;
        allowReceive?: boolean | undefined;
        send?: boolean | undefined;
        recv?: boolean | undefined;
        policy?: {
            send?: boolean | undefined;
            recv?: boolean | undefined;
        } | undefined;
        label?: string | undefined;
        roles?: string[] | undefined;
        metadata?: Record<string, any> | undefined;
        note?: string | undefined;
        source?: "config" | "runtime" | undefined;
    }>, "many">>;
}, "strip", z.ZodTypeAny, {
    group: string;
    share: string;
    relays: string[];
    policies?: {
        pubkey: string;
        allowSend?: boolean | undefined;
        allowReceive?: boolean | undefined;
        send?: boolean | undefined;
        recv?: boolean | undefined;
        policy?: {
            send?: boolean | undefined;
            recv?: boolean | undefined;
        } | undefined;
        label?: string | undefined;
        roles?: string[] | undefined;
        metadata?: Record<string, any> | undefined;
        note?: string | undefined;
        source?: "config" | "runtime" | undefined;
    }[] | undefined;
}, {
    group: string;
    share: string;
    relays: string[];
    policies?: {
        pubkey: string;
        allowSend?: boolean | undefined;
        allowReceive?: boolean | undefined;
        send?: boolean | undefined;
        recv?: boolean | undefined;
        policy?: {
            send?: boolean | undefined;
            recv?: boolean | undefined;
        } | undefined;
        label?: string | undefined;
        roles?: string[] | undefined;
        metadata?: Record<string, any> | undefined;
        note?: string | undefined;
        source?: "config" | "runtime" | undefined;
    }[] | undefined;
}>;
export declare const EchoListenerConfigSchema: z.ZodObject<{
    groupCredential: z.ZodString;
    shareCredentials: z.ZodArray<z.ZodString, "many">;
    relays: z.ZodArray<z.ZodString, "many">;
    timeout: z.ZodOptional<z.ZodNumber>;
}, "strip", z.ZodTypeAny, {
    relays: string[];
    groupCredential: string;
    shareCredentials: string[];
    timeout?: number | undefined;
}, {
    relays: string[];
    groupCredential: string;
    shareCredentials: string[];
    timeout?: number | undefined;
}>;
export declare const NostrKeySchema: z.ZodEffects<z.ZodString, string, string>;
export declare const HexKeySchema: z.ZodString;
export type KeysetParams = z.infer<typeof KeysetParamsSchema>;
export type NodeConfig = z.infer<typeof NodeConfigSchema>;
export type EchoListenerConfig = z.infer<typeof EchoListenerConfigSchema>;
export type NodePolicyInput = z.infer<typeof NodePolicyInputSchema>;
export type NodePolicyStatus = 'online' | 'offline' | 'unknown';
export interface NodePolicy {
    pubkey: string;
    allowSend: boolean;
    allowReceive: boolean;
    label?: string;
    roles?: string[];
    metadata?: Record<string, unknown>;
    note?: string;
    source?: 'config' | 'runtime';
}
export interface NodePolicySummary extends NodePolicy {
    status: NodePolicyStatus;
    lastUpdated?: Date;
}
export interface KeysetCredentials {
    groupCredential: string;
    shareCredentials: string[];
}
export interface ShareDetails {
    idx: number;
}
export interface ShareDetailsWithGroup {
    idx: number;
    threshold: number;
    totalMembers: number;
}
export interface EnhancedNodeConfig extends NodeConfig {
    /** Timeout for initial connection in milliseconds */
    connectionTimeout?: number;
    /** Whether to automatically reconnect on disconnection */
    autoReconnect?: boolean;
}
export interface NodeState {
    isReady: boolean;
    isConnected: boolean;
    isConnecting: boolean;
    lastError?: string;
    connectedRelays: string[];
}
export interface NodeCreationResult {
    node: BifrostNode;
    state: NodeState;
}
export interface NostrKeyPair {
    nsec: string;
    npub: string;
    hexPrivateKey: string;
    hexPublicKey: string;
}
export type { BifrostNode, SignatureEntry, ECDHPackage, SignSessionPackage, GroupPackage, SharePackage } from '@frostr/bifrost';
import type { SignedMessage } from '@cmdcode/nostr-p2p';
import type { PeerConfig } from '@frostr/bifrost';
export interface BifrostNodeEvents {
    '*': (eventName: string, data: unknown) => void;
    'info': (data: unknown) => void;
    'debug': (data: unknown) => void;
    'error': (error: unknown) => void;
    'ready': (node: BifrostNode) => void;
    'closed': (node: BifrostNode) => void;
    'bounced': (reason: string, msg: SignedMessage) => void;
    'message': (msg: SignedMessage) => void;
    '/ecdh/sender/req': (msg: SignedMessage) => void;
    '/ecdh/sender/res': (msgs: SignedMessage[]) => void;
    '/ecdh/sender/rej': (reason: string, pkg: ECDHPackage) => void;
    '/ecdh/sender/ret': (reason: string, pkgs: string) => void;
    '/ecdh/sender/err': (reason: string, msgs: SignedMessage[]) => void;
    '/ecdh/handler/req': (msg: SignedMessage) => void;
    '/ecdh/handler/res': (msg: SignedMessage) => void;
    '/ecdh/handler/rej': (reason: string, msg: SignedMessage) => void;
    '/sign/sender/req': (msg: SignedMessage) => void;
    '/sign/sender/res': (msgs: SignedMessage[]) => void;
    '/sign/sender/rej': (reason: string, pkg: SignSessionPackage) => void;
    '/sign/sender/ret': (reason: string, msgs: SignatureEntry[]) => void;
    '/sign/sender/err': (reason: string, msgs: SignedMessage[]) => void;
    '/sign/handler/req': (msg: SignedMessage) => void;
    '/sign/handler/res': (msg: SignedMessage) => void;
    '/sign/handler/rej': (reason: string, msg: SignedMessage) => void;
    '/ping/handler/req': (msg: SignedMessage) => void;
    '/ping/handler/res': (msg: SignedMessage) => void;
    '/ping/handler/rej': (reason: string, msg: SignedMessage) => void;
    '/ping/handler/ret': (reason: string, data: string) => void;
    '/ping/sender/req': (msg: SignedMessage) => void;
    '/ping/sender/res': (msg: SignedMessage) => void;
    '/ping/sender/rej': (reason: string, msg: SignedMessage | null) => void;
    '/ping/sender/ret': (config: PeerConfig) => void;
    '/ping/sender/err': (reason: string, msg: SignedMessage) => void;
    '/echo/handler/req': (msg: SignedMessage) => void;
    '/echo/handler/res': (msg: SignedMessage) => void;
    '/echo/handler/rej': (reason: string, msg: SignedMessage) => void;
    '/echo/sender/req': (msg: SignedMessage) => void;
    '/echo/sender/res': (msg: SignedMessage) => void;
    '/echo/sender/rej': (reason: string, msg: SignedMessage | null) => void;
    '/echo/sender/ret': (reason: string) => void;
    '/echo/sender/err': (reason: string, msg: SignedMessage) => void;
}
export interface EchoListener {
    cleanup: () => void;
    isActive: boolean;
}
export interface EchoReceivedEvent {
    shareIndex: number;
    shareCredential: string;
    timestamp: Date;
}
export type EchoReceivedCallback = (shareIndex: number, shareCredential: string) => void;
export declare class IglooError extends Error {
    readonly code: string;
    readonly details?: any | undefined;
    constructor(message: string, code: string, details?: any | undefined);
}
export declare class KeysetError extends IglooError {
    constructor(message: string, details?: any);
}
export declare class NodeError extends IglooError {
    constructor(message: string, details?: any);
}
export declare class PolicyError extends IglooError {
    constructor(message: string, details?: any);
}
export declare class RecoveryError extends IglooError {
    constructor(message: string, details?: any);
}
export declare class EchoError extends IglooError {
    constructor(message: string, details?: any);
}
export declare class NostrError extends IglooError {
    constructor(message: string, details?: any);
}
export interface ValidationResult {
    isValid: boolean;
    message?: string;
    normalized?: string;
}
export interface RelayValidationResult extends ValidationResult {
    normalizedRelays?: string[];
    validRelays?: string[];
    errors?: string[];
}
export interface BifrostCredentials {
    group: string;
    shares: string[];
    relays: string[];
}
export interface ValidatedCredentials extends BifrostCredentials {
    isValid: boolean;
    errors: string[];
}
export declare class BifrostValidationError extends IglooError {
    field?: string | undefined;
    constructor(message: string, field?: string | undefined);
}
export declare class NostrValidationError extends IglooError {
    constructor(message: string);
}
