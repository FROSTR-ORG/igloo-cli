// Export all types
export * from './types.js';
// Export keyset management
export { generateKeysetWithSecret, decodeShare, decodeGroup, getShareDetails, getShareDetailsWithGroup, recoverSecretKey, recoverSecretKeyFromCredentials, validateKeysetParams, validateSecretKey, validateSharesCompatibility, validateShareCredentialsCompatibility } from './keyset.js';
// Export node management
export { createBifrostNode, setupNodeEvents, connectNode, closeNode, createAndConnectNode, createConnectedNode, isNodeReady, cleanupBifrostNode } from './node.js';
// Export echo functionality
export { awaitShareEcho, startListeningForAllEchoes, sendEcho, DEFAULT_ECHO_RELAYS } from './echo.js';
// Export ping functionality
export { pingPeer, pingPeers as pingPeersAdvanced, createPingMonitor, pingPeersFromCredentials, runPingDiagnostics, DEFAULT_PING_RELAYS, DEFAULT_PING_TIMEOUT, DEFAULT_PING_INTERVAL } from './ping.js';
// Export nostr utilities
export { nsecToHex, hexToNsec, hexToNpub, npubToHex, generateNostrKeyPair, derivePublicKey, validateHexKey, validateNostrKey } from './nostr.js';
// Export validation functions
export { validateNsec, validateHexPrivkey, validateShare, validateGroup, validateRelay, validateBfcred, validateCredentialFormat, validateRelayList, validateCredentialSet, validateMinimumShares, validateWithOptions, VALIDATION_CONSTANTS } from './validation.js';
// Export peer management functions
export { PeerManager, StaticPeerManager, createPeerManager, createPeerManagerRobust, validatePeerCredentials, extractPeersFromCredentials, pingPeers, checkPeerStatus, DEFAULT_PEER_MONITOR_CONFIG, 
// Pubkey utility functions
normalizePubkey, addPubkeyPrefix, comparePubkeys, extractSelfPubkeyFromCredentials } from './peer.js';
// Export policy helpers
export { normalizeNodePolicyInput, normalizeNodePolicies, prepareNodePolicies, setNodePolicies, updateNodePolicy, getNodePolicies, getNodePolicy, canSendToPeer, canReceiveFromPeer, summarizeNodePolicyMatrix } from './policy.js';
// Export a convenience class for easier usage
export class IglooCore {
    constructor(defaultRelays = [
        "wss://relay.damus.io",
        "wss://relay.primal.net"
    ]) {
        this.defaultRelays = defaultRelays;
    }
    /**
     * Generate a new keyset from a secret key
     */
    async generateKeyset(threshold, totalMembers, secretKey) {
        const { generateKeysetWithSecret } = await import('./keyset.js');
        return generateKeysetWithSecret(threshold, totalMembers, secretKey);
    }
    /**
     * Create and connect a BifrostNode
     */
    async createNode(groupCredential, shareCredential, relaysOrOptions) {
        const { createAndConnectNode } = await import('./node.js');
        let relays;
        let policies;
        let eventConfig;
        if (Array.isArray(relaysOrOptions)) {
            relays = relaysOrOptions;
        }
        else if (relaysOrOptions) {
            relays = relaysOrOptions.relays;
            policies = relaysOrOptions.policies;
            eventConfig = relaysOrOptions.eventConfig;
        }
        return createAndConnectNode({
            group: groupCredential,
            share: shareCredential,
            relays: relays || this.defaultRelays,
            policies
        }, eventConfig);
    }
    /**
     * Create and connect a BifrostNode with enhanced state information
     */
    async createEnhancedNode(groupCredential, shareCredential, relaysOrOptions, legacyOptions) {
        const { createConnectedNode } = await import('./node.js');
        let relays;
        let policies;
        let connectionTimeout;
        let autoReconnect;
        let eventConfig;
        if (Array.isArray(relaysOrOptions)) {
            relays = relaysOrOptions;
            if (legacyOptions) {
                connectionTimeout = legacyOptions.connectionTimeout;
                autoReconnect = legacyOptions.autoReconnect;
            }
        }
        else if (relaysOrOptions) {
            relays = relaysOrOptions.relays;
            policies = relaysOrOptions.policies;
            connectionTimeout = relaysOrOptions.connectionTimeout;
            autoReconnect = relaysOrOptions.autoReconnect;
            eventConfig = relaysOrOptions.eventConfig;
        }
        return createConnectedNode({
            group: groupCredential,
            share: shareCredential,
            relays: relays || this.defaultRelays,
            policies,
            connectionTimeout,
            autoReconnect
        }, eventConfig);
    }
    /**
     * Check if a BifrostNode is ready
     */
    async isNodeReady(node) {
        const { isNodeReady } = await import('./node.js');
        return isNodeReady(node);
    }
    /**
     * Clean up a BifrostNode completely
     */
    async cleanupNode(node) {
        const { cleanupBifrostNode } = await import('./node.js');
        return cleanupBifrostNode(node);
    }
    /**
     * Set node-level peer policies (optionally merging with existing configuration)
     */
    async setNodePolicies(node, policies, options = {}) {
        const { setNodePolicies } = await import('./policy.js');
        return setNodePolicies(node, policies, options);
    }
    /**
     * Update (merge) a single node policy
     */
    async updateNodePolicy(node, policy) {
        const { updateNodePolicy } = await import('./policy.js');
        return updateNodePolicy(node, policy);
    }
    /**
     * Retrieve current policy summaries for the node
     */
    async getNodePolicies(node) {
        const { getNodePolicies } = await import('./policy.js');
        return getNodePolicies(node);
    }
    /**
     * Lookup a policy for a specific peer by pubkey
     */
    async getNodePolicy(node, pubkey) {
        const { getNodePolicy } = await import('./policy.js');
        return getNodePolicy(node, pubkey);
    }
    /**
     * Determine if outbound messaging is allowed for a peer
     */
    async canNodeSendTo(node, pubkey) {
        const { canSendToPeer } = await import('./policy.js');
        return canSendToPeer(node, pubkey);
    }
    /**
     * Determine if inbound messaging is allowed for a peer
     */
    async canNodeReceiveFrom(node, pubkey) {
        const { canReceiveFromPeer } = await import('./policy.js');
        return canReceiveFromPeer(node, pubkey);
    }
    /**
     * Summarize policies as a quick matrix keyed by pubkey
     */
    async summarizeNodePolicies(node) {
        const { summarizeNodePolicyMatrix } = await import('./policy.js');
        return summarizeNodePolicyMatrix(node);
    }
    /**
     * Wait for an echo on a specific share
     */
    async waitForEcho(groupCredential, shareCredential, timeout = 30000) {
        const { awaitShareEcho } = await import('./echo.js');
        return awaitShareEcho(groupCredential, shareCredential, {
            relays: this.defaultRelays,
            timeout
        });
    }
    /**
     * Start listening for echoes on all shares
     */
    async startEchoListeners(groupCredential, shareCredentials, onEchoReceived) {
        const { startListeningForAllEchoes } = await import('./echo.js');
        return startListeningForAllEchoes(groupCredential, shareCredentials, onEchoReceived, { relays: this.defaultRelays });
    }
    /**
     * Recover secret key from shares
     */
    async recoverSecret(groupCredential, shareCredentials) {
        const { recoverSecretKeyFromCredentials } = await import('./keyset.js');
        return recoverSecretKeyFromCredentials(groupCredential, shareCredentials);
    }
    /**
     * Get details about a share
     */
    async getShareInfo(shareCredential) {
        const { getShareDetails } = await import('./keyset.js');
        return getShareDetails(shareCredential);
    }
    /**
     * Generate a new nostr key pair
     */
    async generateKeys() {
        const { generateNostrKeyPair } = await import('./nostr.js');
        return generateNostrKeyPair();
    }
    /**
     * Convert between nostr key formats
     */
    async convertKey(key, targetFormat) {
        const { nsecToHex, hexToNsec, hexToNpub, npubToHex, validateHexKey, validateNostrKey } = await import('./nostr.js');
        if (key.startsWith('nsec')) {
            validateNostrKey(key); // Validate before conversion
            switch (targetFormat) {
                case 'hex': return nsecToHex(key);
                case 'nsec': return key;
                case 'npub': throw new Error('Cannot convert private key to public key format directly');
            }
        }
        else if (key.startsWith('npub')) {
            validateNostrKey(key); // Validate before conversion
            switch (targetFormat) {
                case 'hex': return npubToHex(key);
                case 'npub': return key;
                case 'nsec': throw new Error('Cannot convert public key to private key');
            }
        }
        else {
            // Assume hex format - validate it
            validateHexKey(key);
            switch (targetFormat) {
                case 'hex': return key;
                case 'nsec': return hexToNsec(key);
                case 'npub': return hexToNpub(key);
            }
        }
    }
    /**
     * Derive public key from private key
     */
    async derivePublicKey(privateKey) {
        const { derivePublicKey, validateHexKey, validateNostrKey } = await import('./nostr.js');
        // Validate input before deriving
        if (privateKey.startsWith('nsec')) {
            validateNostrKey(privateKey);
        }
        else {
            validateHexKey(privateKey);
        }
        return derivePublicKey(privateKey);
    }
    /**
     * Validate a credential set (group, shares, relays)
     */
    async validateCredentials(credentials) {
        const { validateCredentialSet } = await import('./validation.js');
        return validateCredentialSet(credentials);
    }
    /**
     * Validate and normalize relay URLs
     */
    async validateRelays(relays) {
        const { validateRelayList } = await import('./validation.js');
        return validateRelayList(relays);
    }
    /**
     * Validate a single credential by type
     */
    async validateCredential(credential, type) {
        const { validateCredentialFormat } = await import('./validation.js');
        return validateCredentialFormat(credential, type);
    }
    /**
     * Validate credentials with advanced options
     */
    async validateWithOptions(credentials, options = {}) {
        const { validateWithOptions } = await import('./validation.js');
        return validateWithOptions(credentials, options);
    }
    // Peer Management Methods
    /**
     * Create a peer manager for monitoring peer status
     */
    async createPeerManager(node, groupCredential, shareCredential, config) {
        const { createPeerManager } = await import('./peer.js');
        return createPeerManager(node, groupCredential, shareCredential, config);
    }
    /**
     * Create a robust peer manager with enhanced error handling and fallback options
     */
    async createPeerManagerRobust(node, groupCredential, shareCredential, config) {
        const { createPeerManagerRobust } = await import('./peer.js');
        return createPeerManagerRobust(node, groupCredential, shareCredential, config);
    }
    /**
     * Validate peer credentials before creating peer manager
     */
    async validatePeerCredentials(groupCredential, shareCredential) {
        const { validatePeerCredentials } = await import('./peer.js');
        return validatePeerCredentials(groupCredential, shareCredential);
    }
    /**
     * Extract peer list from credentials
     */
    async extractPeers(groupCredential, shareCredential) {
        const { extractPeersFromCredentials } = await import('./peer.js');
        return extractPeersFromCredentials(groupCredential, shareCredential);
    }
    /**
     * Check peer status using ping
     */
    async checkPeerStatus(node, groupCredential, shareCredential) {
        const { checkPeerStatus } = await import('./peer.js');
        return checkPeerStatus(node, groupCredential, shareCredential);
    }
    /**
     * Simple ping to get online peers
     */
    async pingPeers(node, timeout) {
        const { pingPeers } = await import('./peer.js');
        return pingPeers(node, timeout);
    }
    /**
     * Ping a specific peer with detailed results
     */
    async pingPeer(node, peerPubkey, options) {
        const { pingPeer } = await import('./ping.js');
        return pingPeer(node, peerPubkey, options);
    }
    /**
     * Ping multiple peers with detailed results and latency
     */
    async pingPeersAdvanced(node, peerPubkeys, options) {
        const { pingPeers } = await import('./ping.js');
        return pingPeers(node, peerPubkeys, options);
    }
    /**
     * Create a ping monitor for continuous peer monitoring
     */
    async createPingMonitor(node, peerPubkeys, config) {
        const { createPingMonitor } = await import('./ping.js');
        return createPingMonitor(node, peerPubkeys, config);
    }
    /**
     * Run comprehensive ping diagnostics
     */
    async runPingDiagnostics(node, peerPubkeys, options) {
        const { runPingDiagnostics } = await import('./ping.js');
        return runPingDiagnostics(node, peerPubkeys, options);
    }
    /**
     * Ping peers from credentials (convenience method)
     */
    async pingPeersFromCredentials(groupCredential, shareCredential, options) {
        const { pingPeersFromCredentials } = await import('./ping.js');
        return pingPeersFromCredentials(groupCredential, shareCredential, {
            relays: this.defaultRelays,
            ...options
        });
    }
    // Pubkey Utility Methods
    /**
     * Normalize a pubkey by removing 02/03 prefix if present
     */
    async normalizePubkey(pubkey) {
        const { normalizePubkey } = await import('./peer.js');
        return normalizePubkey(pubkey);
    }
    /**
     * Add prefix to a pubkey if missing
     */
    async addPubkeyPrefix(pubkey, prefix = '02') {
        const { addPubkeyPrefix } = await import('./peer.js');
        return addPubkeyPrefix(pubkey, prefix);
    }
    /**
     * Compare two pubkeys after normalization
     */
    async comparePubkeys(pubkey1, pubkey2) {
        const { comparePubkeys } = await import('./peer.js');
        return comparePubkeys(pubkey1, pubkey2);
    }
    /**
     * Extract self pubkey from credentials with enhanced error handling
     */
    async extractSelfPubkey(groupCredential, shareCredential, options) {
        const { extractSelfPubkeyFromCredentials } = await import('./peer.js');
        return extractSelfPubkeyFromCredentials(groupCredential, shareCredential, options);
    }
}
// Create a default instance
export const igloo = new IglooCore();
