export * from './types.js';
export { generateKeysetWithSecret, decodeShare, decodeGroup, getShareDetails, getShareDetailsWithGroup, recoverSecretKey, recoverSecretKeyFromCredentials, validateKeysetParams, validateSecretKey, validateSharesCompatibility, validateShareCredentialsCompatibility } from './keyset.js';
export { createBifrostNode, setupNodeEvents, connectNode, closeNode, createAndConnectNode, createConnectedNode, isNodeReady, cleanupBifrostNode, type NodeEventConfig } from './node.js';
export { awaitShareEcho, startListeningForAllEchoes, sendEcho, DEFAULT_ECHO_RELAYS } from './echo.js';
export { pingPeer, pingPeers as pingPeersAdvanced, createPingMonitor, pingPeersFromCredentials, runPingDiagnostics, DEFAULT_PING_RELAYS, DEFAULT_PING_TIMEOUT, DEFAULT_PING_INTERVAL, type PingResult, type PingMonitorConfig, type PingMonitor } from './ping.js';
export { nsecToHex, hexToNsec, hexToNpub, npubToHex, generateNostrKeyPair, derivePublicKey, validateHexKey, validateNostrKey } from './nostr.js';
export { validateNsec, validateHexPrivkey, validateShare, validateGroup, validateRelay, validateBfcred, validateCredentialFormat, validateRelayList, validateCredentialSet, validateMinimumShares, validateWithOptions, VALIDATION_CONSTANTS, type ValidationOptions } from './validation.js';
export { PeerManager, StaticPeerManager, createPeerManager, createPeerManagerRobust, validatePeerCredentials, extractPeersFromCredentials, pingPeers, checkPeerStatus, DEFAULT_PEER_MONITOR_CONFIG, normalizePubkey, addPubkeyPrefix, comparePubkeys, extractSelfPubkeyFromCredentials, type Peer, type PeerMonitorConfig, type EnhancedPeerMonitorConfig, type PeerMonitorResult, type PeerValidationResult, type PeerManagerResult } from './peer.js';
export { normalizeNodePolicyInput, normalizeNodePolicies, prepareNodePolicies, setNodePolicies, updateNodePolicy, getNodePolicies, getNodePolicy, canSendToPeer, canReceiveFromPeer, summarizeNodePolicyMatrix } from './policy.js';
export declare class IglooCore {
    readonly defaultRelays: string[];
    constructor(defaultRelays?: string[]);
    /**
     * Generate a new keyset from a secret key
     */
    generateKeyset(threshold: number, totalMembers: number, secretKey: string): Promise<import("./types.js").KeysetCredentials>;
    /**
     * Create and connect a BifrostNode
     */
    createNode(groupCredential: string, shareCredential: string, relaysOrOptions?: string[] | CreateNodeOptions): Promise<import("./types.js").BifrostNode>;
    /**
     * Create and connect a BifrostNode with enhanced state information
     */
    createEnhancedNode(groupCredential: string, shareCredential: string, relaysOrOptions?: string[] | CreateEnhancedNodeOptions, legacyOptions?: {
        connectionTimeout?: number;
        autoReconnect?: boolean;
    }): Promise<import("./types.js").NodeCreationResult>;
    /**
     * Check if a BifrostNode is ready
     */
    isNodeReady(node: any): Promise<boolean>;
    /**
     * Clean up a BifrostNode completely
     */
    cleanupNode(node: any): Promise<void>;
    /**
     * Set node-level peer policies (optionally merging with existing configuration)
     */
    setNodePolicies(node: any, policies: NodePolicyInput[], options?: {
        merge?: boolean;
    }): Promise<NodePolicySummary[]>;
    /**
     * Update (merge) a single node policy
     */
    updateNodePolicy(node: any, policy: NodePolicyInput): Promise<NodePolicySummary | undefined>;
    /**
     * Retrieve current policy summaries for the node
     */
    getNodePolicies(node: any): Promise<NodePolicySummary[]>;
    /**
     * Lookup a policy for a specific peer by pubkey
     */
    getNodePolicy(node: any, pubkey: string): Promise<NodePolicySummary | undefined>;
    /**
     * Determine if outbound messaging is allowed for a peer
     */
    canNodeSendTo(node: any, pubkey: string): Promise<boolean>;
    /**
     * Determine if inbound messaging is allowed for a peer
     */
    canNodeReceiveFrom(node: any, pubkey: string): Promise<boolean>;
    /**
     * Summarize policies as a quick matrix keyed by pubkey
     */
    summarizeNodePolicies(node: any): Promise<Record<string, {
        send: boolean;
        recv: boolean;
        status: import("./types.js").NodePolicyStatus;
    }>>;
    /**
     * Wait for an echo on a specific share
     */
    waitForEcho(groupCredential: string, shareCredential: string, timeout?: number): Promise<boolean>;
    /**
     * Start listening for echoes on all shares
     */
    startEchoListeners(groupCredential: string, shareCredentials: string[], onEchoReceived: (shareIndex: number, shareCredential: string) => void): Promise<import("./types.js").EchoListener>;
    /**
     * Recover secret key from shares
     */
    recoverSecret(groupCredential: string, shareCredentials: string[]): Promise<string>;
    /**
     * Get details about a share
     */
    getShareInfo(shareCredential: string): Promise<{
        idx: number;
    }>;
    /**
     * Generate a new nostr key pair
     */
    generateKeys(): Promise<import("./types.js").NostrKeyPair>;
    /**
     * Convert between nostr key formats
     */
    convertKey(key: string, targetFormat: 'hex' | 'nsec' | 'npub'): Promise<string>;
    /**
     * Derive public key from private key
     */
    derivePublicKey(privateKey: string): Promise<{
        npub: string;
        hexPublicKey: string;
    }>;
    /**
     * Validate a credential set (group, shares, relays)
     */
    validateCredentials(credentials: {
        group: string;
        shares: string[];
        relays: string[];
    }): Promise<{
        isValid: boolean;
        groupValid: boolean;
        shareResults: import("./types.js").ValidationResult[];
        relayResults: import("./types.js").ValidationResult[];
        errors: string[];
    }>;
    /**
     * Validate and normalize relay URLs
     */
    validateRelays(relays: string[]): Promise<import("./types.js").RelayValidationResult>;
    /**
     * Validate a single credential by type
     */
    validateCredential(credential: string, type: 'share' | 'group' | 'cred'): Promise<import("./types.js").ValidationResult>;
    /**
     * Validate credentials with advanced options
     */
    validateWithOptions(credentials: {
        group: string;
        shares: string[];
        relays: string[];
    }, options?: {
        strict?: boolean;
        normalizeRelays?: boolean;
        requireMinShares?: number;
    }): Promise<import("./types.js").ValidatedCredentials>;
    /**
     * Create a peer manager for monitoring peer status
     */
    createPeerManager(node: any, groupCredential: string, shareCredential: string, config?: any): Promise<import("./peer.js").PeerManager>;
    /**
     * Create a robust peer manager with enhanced error handling and fallback options
     */
    createPeerManagerRobust(node: any, groupCredential: string, shareCredential: string, config?: any): Promise<import("./peer.js").PeerManagerResult>;
    /**
     * Validate peer credentials before creating peer manager
     */
    validatePeerCredentials(groupCredential: string, shareCredential: string): Promise<import("./peer.js").PeerValidationResult>;
    /**
     * Extract peer list from credentials
     */
    extractPeers(groupCredential: string, shareCredential: string): Promise<string[]>;
    /**
     * Check peer status using ping
     */
    checkPeerStatus(node: any, groupCredential: string, shareCredential: string): Promise<{
        pubkey: string;
        status: "online" | "offline";
    }[]>;
    /**
     * Simple ping to get online peers
     */
    pingPeers(node: any, timeout?: number): Promise<string[]>;
    /**
     * Ping a specific peer with detailed results
     */
    pingPeer(node: any, peerPubkey: string, options?: any): Promise<import("./ping.js").PingResult>;
    /**
     * Ping multiple peers with detailed results and latency
     */
    pingPeersAdvanced(node: any, peerPubkeys: string[], options?: any): Promise<import("./ping.js").PingResult[]>;
    /**
     * Create a ping monitor for continuous peer monitoring
     */
    createPingMonitor(node: any, peerPubkeys: string[], config?: any): Promise<import("./ping.js").PingMonitor>;
    /**
     * Run comprehensive ping diagnostics
     */
    runPingDiagnostics(node: any, peerPubkeys: string[], options?: any): Promise<{
        summary: {
            totalRounds: number;
            totalPeers: number;
            averageLatency: number;
            successRate: number;
            fastestPeer?: string;
            slowestPeer?: string;
        };
        rounds: import("./ping.js").PingResult[][];
        peerStats: {
            [pubkey: string]: {
                successCount: number;
                totalAttempts: number;
                averageLatency: number;
                minLatency: number;
                maxLatency: number;
                successRate: number;
            };
        };
    }>;
    /**
     * Ping peers from credentials (convenience method)
     */
    pingPeersFromCredentials(groupCredential: string, shareCredential: string, options?: any): Promise<import("./ping.js").PingResult[]>;
    /**
     * Normalize a pubkey by removing 02/03 prefix if present
     */
    normalizePubkey(pubkey: string): Promise<string>;
    /**
     * Add prefix to a pubkey if missing
     */
    addPubkeyPrefix(pubkey: string, prefix?: '02' | '03'): Promise<string>;
    /**
     * Compare two pubkeys after normalization
     */
    comparePubkeys(pubkey1: string, pubkey2: string): Promise<boolean>;
    /**
     * Extract self pubkey from credentials with enhanced error handling
     */
    extractSelfPubkey(groupCredential: string, shareCredential: string, options?: {
        normalize?: boolean;
        suppressWarnings?: boolean;
    }): Promise<{
        pubkey: string | null;
        warnings: string[];
    }>;
}
export declare const igloo: IglooCore;
import type { NodePolicyInput, NodePolicySummary } from './types.js';
import type { NodeEventConfig } from './node.js';
type CreateNodeOptions = {
    relays?: string[];
    policies?: NodePolicyInput[];
    eventConfig?: NodeEventConfig;
};
type CreateEnhancedNodeOptions = CreateNodeOptions & {
    connectionTimeout?: number;
    autoReconnect?: boolean;
};
